[
    {
        "id": "4d0f0c0771ab4500",
        "type": "subflow",
        "name": "Rest API Read downlink/ Write uplink",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 300,
                "y": 360,
                "wires": [
                    {
                        "id": "0f12d8169e956e8a"
                    },
                    {
                        "id": "2b99374ebd874273"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 1760,
                "y": 460,
                "wires": [
                    {
                        "id": "0a38a21e9afb8246",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [
            {
                "name": "dataDirection",
                "type": "str",
                "value": "uplink",
                "ui": {
                    "icon": "font-awesome/fa-location-arrow",
                    "label": {
                        "en-US": "Direction"
                    },
                    "type": "select",
                    "opts": {
                        "opts": [
                            {
                                "l": {
                                    "en-US": "Uplink"
                                },
                                "v": "uplink"
                            },
                            {
                                "l": {
                                    "en-US": "Downlink"
                                },
                                "v": "downlink"
                            }
                        ]
                    }
                }
            }
        ],
        "meta": {},
        "color": "#DDAA99",
        "status": {
            "x": 660,
            "y": 580,
            "wires": [
                {
                    "id": "7771e6d6a85d429e",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "f7f1301c75c39d11",
        "type": "function",
        "z": "4d0f0c0771ab4500",
        "name": "BACnet Object Exist ?",
        "func": "let device = msg.device;\nconst debug = flow.get(\"$parent.g_debug\");\n\nswitch (msg.statusCode) {\n    //////////////////////////////////////////////////    \n    // Case 200 : \"Success\" > Stops here OR continue to read Downlink Objects. \n    // Case 200 : \"Object does not exist\" > Create Objects\n    //////////////////////////////////////////////////\n    case 200:\n        if (msg.payload.includes(\"Unknown Object\")) {\n            debug(device, \"creation\", `${device.identity.deviceName} : Some BACnet objects don't exist`);\n            return [{ device: device }, null];       // Create Downlink Objects\n        }\n        else {\n            switch (env.get(\"dataDirection\")) {\n                case \"uplink\":\n                    debug(device, \"up\", `${device.identity.deviceName} (RestAPI) : Write Uplink Objects`);\n\n                    const dataDirection = Object.values(device.bacnet.objects).map(obj => obj.dataDirection);\n\n                    if (dataDirection.some(direction => { return direction === \"downlink\" })) {\n                        return [null, { device: device }];    // Continue to read downlink Objects\n                    }\n                    else {\n                        debug(device, \"txTime\", `${device.identity.deviceName} (${device.controller.protocol}) : TX time = ${Date.now() - device.transmitTime} ms`);\n                        return [null, null];                 // Stops here\n                    }\n                    break;\n                case \"downlink\":\n                    debug(device, \"down\", `${device.identity.deviceName} (RestAPI) : Read Downlink Objects`);\n                    return [null, { device: device, payload: JSON.parse(msg.payload) }];\n                    break;\n                default:\n                    \n            }\n            \n        }\n\n    case 400:\n        node.error(\"Error : Bad HTTP Request\");\n        if (msg.payload.includes(\"write-access-denied\")) {\n            node.error(\"Error : Trying to write a Read Only object (analogInput)\");\n        }\n        return [null, null];\n\n    case 401:\n        node.error(\"Error : Can't connect to controller : Authorization error\");\n        return [null, null];\n\n    case 500:\n        node.error(\"Error : Server Error 500\");\n        return [null, null];\n\n    case 404:\n        node.error(\"Error : 404\");\n        return [null, null];\n\n    case \"ETIMEDOUT\":\n        node.error(\"Error : Can't connect to controller : TimeOut\");\n        return [null, null];\n\n    case \"UNABLE_TO_VERIFY_LEAF_SIGNATURE\":\n        node.error(\"Error : You forgot to enable the TLS config in your HTTP node\");\n        return [null, null];\n\n}\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1000,
        "y": 360,
        "wires": [
            [
                "2ea60b064ee5fd3e",
                "4b7b80e5534bb942"
            ],
            [
                "da9c771d29ce6201"
            ]
        ],
        "icon": "node-red/switch.svg"
    },
    {
        "id": "ce546944050fc09d",
        "type": "http request",
        "z": "4d0f0c0771ab4500",
        "g": "9b9ee65b4f88d4a8",
        "name": "HTTP REQUEST",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "38c4db63982e52db",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 770,
        "y": 360,
        "wires": [
            [
                "f7f1301c75c39d11"
            ]
        ]
    },
    {
        "id": "0f12d8169e956e8a",
        "type": "function",
        "z": "4d0f0c0771ab4500",
        "g": "9b9ee65b4f88d4a8",
        "name": "READ/WRITE Objects",
        "func": "\nlet device = msg.device;\nlet dataDirection = env.get('dataDirection')\nlet bacnetObjects = device.bacnet.objects;\n\nif(device.controller.protocol != \"restAPIBacnet\") return null;\n\nswitch (device.controller.model) {\n\n  ///////////////////////////////////////////////////////////\n  ////// Distech Controls Eclypse APEX\n  ////// https://www.postman.com/distech/distech-ecy-v2-public/request/3qk28wy/write-property-multiple\n  ///////////////////////////////////////////////////////////\n  case \"distechControlsV2\":\n    /********* HTTP Request Write Properties\n    {\n        \"method\": \"POST\",\n        \"url\": \"https://@IP/api/rest/v2/services/bacnet/local/objects/write-property-multiple\",\n        \"headers\": {Authorization: httpAuthentication,\n                  ContentType: \"application/json\"},\n        \n        \"payload\": {\n            \"encode\": \"text\",\n            \"property-references\": [\n                {\n                  \"type\": \"analogValue\",\n                  \"instance\": y,\n                  \"property\": \"presentValue\",\n                  \"value\" : \"xx\"\n                },\n                {\n                  \"type\": \"analogValue\",\n                  \"instance\": y,\n                  \"property\": \"presentValue\",\n                  \"value\" : \"xx\"\n                },\n                ...\n            ]\n        },\n        \"requestTimeout\" : xxx (ms)\n    }\n    */\n\n    let property_references = [];\n    for (let object in bacnetObjects) {\n      if (bacnetObjects[object].dataDirection == dataDirection) {\n        let temp = {}\n        switch (dataDirection) {\n          case \"uplink\":\n            temp = '{ \"type\": \"' + bacnetObjects[object].objectType + '\", \"instance\": ' + bacnetObjects[object].instanceNum + ', \"property\": \"presentValue\", \"value\": ' + bacnetObjects[object].value + ' }';\n            property_references.push(JSON.parse(temp));\n            break;\n          case \"downlink\":\n            temp = '{ \"type\": \"' + bacnetObjects[object].objectType + '\", \"instance\": ' + bacnetObjects[object].instanceNum + ', \"property\": \"presentValue\"}';\n            property_references.push(JSON.parse(temp));\n            break;\n          default:\n            \n        }\n      }\n    }\n\n    // Return HTTP Request\n    switch (dataDirection) {\n      case \"uplink\":\n        return {\n          \"method\": \"POST\",\n          \"url\": \"https://\" + device.controller.ipAddress + \"/api/rest/v2/services/bacnet/local/objects/write-property-multiple\",\n          \"headers\": {\n            Authorization: device.controller.httpAuthentication,\n            ContentType: \"application/json\"\n          },\n          \"payload\": {\n            \"encode\": \"text\",\n            \"property-references\": property_references\n          },\n          \"requestTimeout\": flow.get('$parent.g_httpRequestTimeOut'),\n          \"device\": device\n        }\n        break;\n      case \"downlink\":\n        return {\n          \"method\": \"POST\",\n          \"url\": \"https://\" + device.controller.ipAddress + \"/api/rest/v2/services/bacnet/local/objects/read-property-multiple\",\n          \"headers\": {\n            Authorization: device.controller.httpAuthentication,\n            ContentType: \"application/json\"\n          },\n          \"payload\": {\n            \"encode\": \"text\",\n            \"property-references\": property_references\n          },\n          \"requestTimeout\": flow.get('$parent.g_httpRequestTimeOut'),\n          \"device\": device\n        }\n        break;\n      default:\n      return\n        break;\n    }\n    \n\n\n  ///////////////////////////////////////////////////////////\n  ////// XXXXX Controller\n  ////// URL to the API documentation\n  ///////////////////////////////////////////////////////////\n  case \"anotherController\":\n\n\n}\n\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 360,
        "wires": [
            [
                "ce546944050fc09d"
            ]
        ]
    },
    {
        "id": "2ea60b064ee5fd3e",
        "type": "function",
        "z": "4d0f0c0771ab4500",
        "g": "885bfde15373d132",
        "name": "CREATE Objects",
        "func": "\nlet device = msg.device;\nlet bacnetObjects = device.bacnet.objects;\n\nswitch (device.controller.model) {\n\n  ///////////////////////////////////////////////////////////\n  ////// Distech Controls Eclypse APEX\n  ////// https://www.postman.com/distech/distech-ecy-v2-public/request/57jbx8w/create-objects-multiple\n  ///////////////////////////////////////////////////////////\n  case \"distechControlsV2\":\n\n    /**********  Objects creation on the controller\n    {\n        \"method\": \"POST\",\n        \"url\": \"https://\" + flow.get('$parent.g_controllerIP') +\"/api/rest/v2/batch\",\n        \"headers\": {Authorization: flow.get('$parent.g_httpAuthentication'),\n                  ContentType: \"application/json\"}\n        \"payload\":{\n            \"requests\": [\n                {\n                  \"id\": \"1\",\n                  \"method\": \"POST\",\n                  \"url\": \"/api/rest/v2/services/bacnet/local/objects/add\",\n                  \"body\": {\n                    \"object-type\": \"AnalogValue\",\n                    \"instance-number\": 10010,\n                    \"name\": \"apiAVTest10\"\n                  }\n                },\n                {\n                  \"id\": \"2\",\n                  \"method\": \"POST\",\n                  \"url\": \"/api/rest/v2/services/bacnet/local/objects/add\",\n                  \"body\": {\n                    \"object-type\": \"BinaryValue\",\n                    \"instance-number\": 10010,\n                    \"name\": \"apiBVTest10\"\n                  }\n                },\n                ...\n            ]\n        },\n        \"requestTimeout\" : xxx (ms)\n    }\n    */\n\n\n    let requests = [], i = 1;\n\n    for (let object in bacnetObjects) {\n      let temp = '{ \"id\": \"' + (i++) + '\", \"method\": \"POST\", \"url\": \"/api/rest/v2/services/bacnet/local/objects/add\", \"body\": { \"object-type\": \"' + bacnetObjects[object].objectType + '\", \"instance-number\": ' + bacnetObjects[object].instanceNum + ', \"name\": \"' + bacnetObjects[object].objectName + '\" } }';\n      requests.push(JSON.parse(temp));\n    }\n\n    // Return HTTP Request\n    return {\n      \"method\": \"POST\",\n      \"url\": \"https://\" + device.controller.ipAddress + \"/api/rest/v2/batch\",\n      \"headers\": {\n        Authorization: device.controller.httpAuthentication,\n        ContentType: \"application/json\"\n      },\n      \"payload\": { \"requests\": requests },\n      \"requestTimeout\": flow.get('$parent.g_httpRequestTimeOut'),\n      \"device\": device\n    }\n\n  ///////////////////////////////////////////////////////////\n  ////// XXXXX Controller\n  ////// URL to the API documentation\n  ///////////////////////////////////////////////////////////\n  case \"anotherController\":\n\n  \n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1270,
        "y": 260,
        "wires": [
            [
                "66bac6f6d3ef486f"
            ]
        ]
    },
    {
        "id": "66bac6f6d3ef486f",
        "type": "http request",
        "z": "4d0f0c0771ab4500",
        "g": "885bfde15373d132",
        "name": "HTTP REQUEST",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "38c4db63982e52db",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1550,
        "y": 260,
        "wires": [
            [
                "2d70ba55e9d6dbc8",
                "f8147aafe51f87df"
            ]
        ]
    },
    {
        "id": "2d70ba55e9d6dbc8",
        "type": "function",
        "z": "4d0f0c0771ab4500",
        "g": "885bfde15373d132",
        "name": "READ/WRITE Objects",
        "func": "\nlet device = msg.device;\nlet previousValues = flow.get(\"$parent.g_previousValues\");\nlet dataDirection = env.get('dataDirection')\nlet bacnetObjects = device.bacnet.objects;\n\nswitch (device.controller.model) {\n\n    ///////////////////////////////////////////////////////////\n    ////// Distech Controls Eclypse APEX\n    ////// https://www.postman.com/distech/distech-ecy-v2-public/request/3qk28wy/write-property-multiple\n    ///////////////////////////////////////////////////////////\n    case \"distechControlsV2\":\n        /********* HTTP Request Write Properties\n        {\n            \"method\": \"POST\",\n            \"url\": \"https://@IP/api/rest/v2/services/bacnet/local/objects/write-property-multiple\",\n            \"headers\": {Authorization: httpAuthentication,\n                      ContentType: \"application/json\"},\n            \n            \"payload\": {\n                \"encode\": \"text\",\n                \"property-references\": [\n                    {\n                      \"type\": \"analogValue\",\n                      \"instance\": y,\n                      \"property\": \"presentValue\",\n                      \"value\" : \"xx\"\n                    },\n                    {\n                      \"type\": \"analogValue\",\n                      \"instance\": y,\n                      \"property\": \"presentValue\",\n                      \"value\" : \"xx\"\n                    },\n                    ...\n                ]\n            },\n            \"requestTimeout\" : xxx (ms)\n        }\n        */\n\n        let property_references = [];\n        for (let object in bacnetObjects) {\n            let temp = {}\n            switch (bacnetObjects[object].dataDirection) {\n                case \"uplink\":\n                    temp = '{ \"type\": \"' + bacnetObjects[object].objectType + '\", \"instance\": ' + bacnetObjects[object].instanceNum + ', \"property\": \"presentValue\", \"value\": ' + bacnetObjects[object].value + ' }';\n                    property_references.push(JSON.parse(temp));\n                    break;\n                case \"downlink\":\n                //  if it exist take the previous value of the downlink BACnet object\n                    if (previousValues.hasOwnProperty(device.identity.deviceName)){\n                        temp = '{ \"type\": \"' + bacnetObjects[object].objectType + '\", \"instance\": ' + bacnetObjects[object].instanceNum + ', \"property\": \"presentValue\", \"value\": ' + previousValues[device.identity.deviceName].bacnet.objects[object].value + ' }';\n                    property_references.push(JSON.parse(temp));\n                    }else{\n                    temp = '{ \"type\": \"' + bacnetObjects[object].objectType + '\", \"instance\": ' + bacnetObjects[object].instanceNum + ', \"property\": \"presentValue\", \"value\": ' + bacnetObjects[object].value + ' }';\n                    property_references.push(JSON.parse(temp));\n                    }\n\n                    break;\n                default:\n            }\n        \n        }\n\n    // Return HTTP Request\n    return {\n        \"method\": \"POST\",\n        \"url\": \"https://\" + device.controller.ipAddress + \"/api/rest/v2/services/bacnet/local/objects/write-property-multiple\",\n        \"headers\": {\n            Authorization: device.controller.httpAuthentication,\n            ContentType: \"application/json\"\n        },\n        \"payload\": {\n            \"encode\": \"text\",\n            \"property-references\": property_references\n        },\n        \"requestTimeout\": global.get('g_httpRequestTimeOut'),\n        \"device\": device\n    }\n\n    ///////////////////////////////////////////////////////////\n    ////// XXXXX Controller\n    ////// URL to the API documentation\n    ///////////////////////////////////////////////////////////\n    case \"anotherController\":\n\n\n}\n\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 320,
        "wires": [
            [
                "ba52022330bc5460"
            ]
        ]
    },
    {
        "id": "ba52022330bc5460",
        "type": "http request",
        "z": "4d0f0c0771ab4500",
        "g": "885bfde15373d132",
        "name": "HTTP REQUEST",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "38c4db63982e52db",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1550,
        "y": 320,
        "wires": [
            [
                "89ccb3dd49118281",
                "0a38a21e9afb8246"
            ]
        ]
    },
    {
        "id": "f8147aafe51f87df",
        "type": "function",
        "z": "4d0f0c0771ab4500",
        "g": "885bfde15373d132",
        "name": "Creation results",
        "func": "let device = msg.device;\nconst debug = flow.get('$parent.g_debug');\n\nswitch (msg.statusCode) {\n    //////////////////////////////////////////////////    \n    // Case 200 : \"Success\" > Objects have been created\n    //////////////////////////////////////////////////\n    case 200:\n        if (msg.payload.includes(\"\\\"status\\\":200\")) {\n            debug(device, \"creation\", `${device.identity.deviceName} (RestAPI) : Some BACnet objects have been created`);\n        }\n        if (msg.payload.includes(\"Instance already exists\") || msg.payload.includes(\"Object with same name already exists\")) {\n            flow.set('g_errorObjectCreation', flow.get('g_errorObjectCreation') + 1);\n            node.error(`${device.identity.deviceName} : Some BACnet objects already existed`);\n        }\n        break;\n\n    case 400:\n        node.error(\"Error : Bad HTTP Request\");\n        break;\n\n    case 401:\n        node.error(\"Error : Can't connect to controller : Authorization error\");\n        break;\n\n    case 500:\n        node.error(\"Error : Server Error 500\");\n        break;\n\n    case 404:\n        node.error(\"Error : 404\");\n        break;\n\n\n    case \"ETIMEDOUT\":\n        node.error(\"Error : Can't connect to controller : TimeOut\");\n        break;\n\n    case \"UNABLE_TO_VERIFY_LEAF_SIGNATURE\":\n        node.error(\"Error : You forgot to enable the TLS config in your HTTP node\");\n        break;\n\n}\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "// Le code ajouté ici sera exécuté une fois\n// à chaque démarrage du noeud.\nglobal.set('g_errorObjectCreation', 0);",
        "finalize": "",
        "libs": [],
        "x": 1780,
        "y": 260,
        "wires": [
            []
        ],
        "icon": "node-red/alert.svg"
    },
    {
        "id": "89ccb3dd49118281",
        "type": "function",
        "z": "4d0f0c0771ab4500",
        "g": "885bfde15373d132",
        "name": "Debug Write",
        "func": "let device = msg.device;\nconst debug = flow.get('$parent.g_debug');\n\ndebug(device, \"txTime\", `${device.identity.deviceName} (${device.controller.protocol}) : TX time = ${Date.now() - device.transmitTime} ms`); \n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1770,
        "y": 320,
        "wires": [
            [
                "10b7ab4b29ca7652"
            ]
        ]
    },
    {
        "id": "3e54183a38bf5e63",
        "type": "change",
        "z": "4d0f0c0771ab4500",
        "name": "Read/Write in process",
        "rules": [
            {
                "t": "delete",
                "p": "payload",
                "pt": "msg"
            },
            {
                "t": "set",
                "p": "payload.text",
                "pt": "msg",
                "to": "$env('dataDirection') & \" Read/Write in process...\"",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "payload.fill",
                "pt": "msg",
                "to": "yellow",
                "tot": "str"
            },
            {
                "t": "set",
                "p": "payload.shape",
                "pt": "msg",
                "to": "ring",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 460,
        "y": 600,
        "wires": [
            [
                "7771e6d6a85d429e"
            ]
        ]
    },
    {
        "id": "27423566a12df2b6",
        "type": "change",
        "z": "4d0f0c0771ab4500",
        "name": "Read/Write complete",
        "rules": [
            {
                "t": "delete",
                "p": "payload",
                "pt": "msg"
            },
            {
                "t": "set",
                "p": "payload.text",
                "pt": "msg",
                "to": "$env('dataDirection') & \" Read/Write complete\"",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "payload.fill",
                "pt": "msg",
                "to": "green",
                "tot": "str"
            },
            {
                "t": "set",
                "p": "payload.shape",
                "pt": "msg",
                "to": "dot",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 460,
        "y": 560,
        "wires": [
            [
                "7771e6d6a85d429e"
            ]
        ]
    },
    {
        "id": "acb069d508f98b32",
        "type": "change",
        "z": "4d0f0c0771ab4500",
        "name": "Object creation complete",
        "rules": [
            {
                "t": "delete",
                "p": "payload",
                "pt": "msg"
            },
            {
                "t": "set",
                "p": "payload.text",
                "pt": "msg",
                "to": "$env('dataDirection') & \" Object creation complete\"",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "payload.fill",
                "pt": "msg",
                "to": "green",
                "tot": "str"
            },
            {
                "t": "set",
                "p": "payload.shape",
                "pt": "msg",
                "to": "dot",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 470,
        "y": 640,
        "wires": [
            [
                "7771e6d6a85d429e"
            ]
        ]
    },
    {
        "id": "f6852e694b142d26",
        "type": "change",
        "z": "4d0f0c0771ab4500",
        "name": "Object creation in process",
        "rules": [
            {
                "t": "delete",
                "p": "payload",
                "pt": "msg"
            },
            {
                "t": "set",
                "p": "payload.text",
                "pt": "msg",
                "to": "$env('dataDirection') & \" Object creation in process...\"",
                "tot": "jsonata"
            },
            {
                "t": "set",
                "p": "payload.fill",
                "pt": "msg",
                "to": "yellow",
                "tot": "str"
            },
            {
                "t": "set",
                "p": "payload.shape",
                "pt": "msg",
                "to": "ring",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 470,
        "y": 520,
        "wires": [
            [
                "7771e6d6a85d429e"
            ]
        ]
    },
    {
        "id": "10b7ab4b29ca7652",
        "type": "link out",
        "z": "4d0f0c0771ab4500",
        "g": "885bfde15373d132",
        "name": "link out Object creation complete",
        "mode": "link",
        "links": [
            "38ea802be3c22a0c"
        ],
        "x": 1875,
        "y": 320,
        "wires": []
    },
    {
        "id": "38ea802be3c22a0c",
        "type": "link in",
        "z": "4d0f0c0771ab4500",
        "name": "link in Object creation complete",
        "links": [
            "10b7ab4b29ca7652"
        ],
        "x": 295,
        "y": 640,
        "wires": [
            [
                "acb069d508f98b32"
            ]
        ]
    },
    {
        "id": "00b43931e829d4ca",
        "type": "link in",
        "z": "4d0f0c0771ab4500",
        "name": "link in Read/Write in progress",
        "links": [
            "2b99374ebd874273"
        ],
        "x": 295,
        "y": 600,
        "wires": [
            [
                "3e54183a38bf5e63"
            ]
        ]
    },
    {
        "id": "4b3ca7933bc1fed6",
        "type": "link in",
        "z": "4d0f0c0771ab4500",
        "name": "link in Read/Write complete",
        "links": [
            "2f2785718af66d1d"
        ],
        "x": 295,
        "y": 560,
        "wires": [
            [
                "27423566a12df2b6"
            ]
        ]
    },
    {
        "id": "3b5df9fc790a17c3",
        "type": "link in",
        "z": "4d0f0c0771ab4500",
        "name": "link in object creation",
        "links": [
            "4b7b80e5534bb942"
        ],
        "x": 295,
        "y": 520,
        "wires": [
            [
                "f6852e694b142d26"
            ]
        ]
    },
    {
        "id": "4b7b80e5534bb942",
        "type": "link out",
        "z": "4d0f0c0771ab4500",
        "name": "link out object creation",
        "mode": "link",
        "links": [
            "3b5df9fc790a17c3"
        ],
        "x": 1015,
        "y": 260,
        "wires": []
    },
    {
        "id": "2b99374ebd874273",
        "type": "link out",
        "z": "4d0f0c0771ab4500",
        "name": "link out Read/Write in progress",
        "mode": "link",
        "links": [
            "00b43931e829d4ca"
        ],
        "x": 335,
        "y": 400,
        "wires": []
    },
    {
        "id": "b287b7ee19c1eaae",
        "type": "function",
        "z": "4d0f0c0771ab4500",
        "name": "Store Downlink object",
        "func": "/////////////////////////////////////////////////////////////////////\n/////////////////  Store Downlink Objects              //////////////\n/////////////////////////////////////////////////////////////////////\n/* This function stores the downlink data from the controller */\n\nlet device = msg.device;\nlet bacnetObjects = device.bacnet.objects;\n\n// For InfluxDB support\ndevice.influxdb.source = \"downlink\";\n\nswitch (device.controller.model) {\n    case \"distechControlsV2\":\n        let donwlinkObjects = msg.payload;\n\n        for (let i = 0; i < donwlinkObjects.results.length; i++) {\n            Object.values(bacnetObjects).forEach(obj => {\n                if (donwlinkObjects.results[i].type == obj.objectType && donwlinkObjects.results[i].instance == obj.instanceNum) {\n                    if (obj.objectType == \"analogValue\") obj.value = Number(donwlinkObjects.results[i].value);\n                    if (obj.objectType == \"binaryValue\") obj.value = donwlinkObjects.results[i].value;\n                }\n            });\n        }\n\n        return {\n            device: device\n        };\n\n\n\n    ///////////////////////////////////////////////////////////\n    ////// XXXXX Controller\n    ////// URL to the API documentation\n    ///////////////////////////////////////////////////////////\n    case \"anotherController\":\n\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1420,
        "y": 440,
        "wires": [
            [
                "1d10e0c583e84916"
            ]
        ]
    },
    {
        "id": "2f2785718af66d1d",
        "type": "link out",
        "z": "4d0f0c0771ab4500",
        "name": "link out Read/Write complete",
        "mode": "link",
        "links": [
            "4b3ca7933bc1fed6"
        ],
        "x": 1755,
        "y": 520,
        "wires": []
    },
    {
        "id": "da9c771d29ce6201",
        "type": "switch",
        "z": "4d0f0c0771ab4500",
        "name": "",
        "property": "dataDirection",
        "propertyType": "env",
        "rules": [
            {
                "t": "eq",
                "v": "downlink",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "uplink",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 1175,
        "y": 460,
        "wires": [
            [
                "b287b7ee19c1eaae"
            ],
            [
                "1d10e0c583e84916"
            ]
        ],
        "outputLabels": [
            "downlink",
            "uplink"
        ],
        "l": false
    },
    {
        "id": "7771e6d6a85d429e",
        "type": "junction",
        "z": "4d0f0c0771ab4500",
        "x": 600,
        "y": 580,
        "wires": [
            []
        ]
    },
    {
        "id": "1d10e0c583e84916",
        "type": "junction",
        "z": "4d0f0c0771ab4500",
        "x": 1680,
        "y": 480,
        "wires": [
            [
                "2f2785718af66d1d",
                "0a38a21e9afb8246"
            ]
        ]
    },
    {
        "id": "0a38a21e9afb8246",
        "type": "junction",
        "z": "4d0f0c0771ab4500",
        "x": 1720,
        "y": 460,
        "wires": [
            []
        ]
    },
    {
        "id": "9b9ee65b4f88d4a8",
        "type": "group",
        "z": "4d0f0c0771ab4500",
        "name": "Read/Write BACnet Objects",
        "style": {
            "stroke": "#ff0000",
            "fill": "#ffbfbf",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "ce546944050fc09d",
            "0f12d8169e956e8a"
        ],
        "x": 394,
        "y": 319,
        "w": 492,
        "h": 82
    },
    {
        "id": "885bfde15373d132",
        "type": "group",
        "z": "4d0f0c0771ab4500",
        "name": "Create missing BACnet Objects",
        "style": {
            "stroke": "#ff0000",
            "fill": "#ffbfbf",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "2ea60b064ee5fd3e",
            "66bac6f6d3ef486f",
            "2d70ba55e9d6dbc8",
            "ba52022330bc5460",
            "f8147aafe51f87df",
            "89ccb3dd49118281",
            "10b7ab4b29ca7652"
        ],
        "x": 1154,
        "y": 219,
        "w": 762,
        "h": 142
    },
    {
        "id": "38c4db63982e52db",
        "type": "tls-config",
        "name": "",
        "cert": "",
        "key": "",
        "ca": "",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "",
        "verifyservercert": false,
        "alpnprotocol": ""
    },
    {
        "id": "5cc5759c4e59a5b9",
        "type": "tab",
        "label": "LoRaBAC",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "61078575c808c2ab",
        "type": "group",
        "z": "5cc5759c4e59a5b9",
        "name": "MQTT (to Configure)",
        "style": {
            "stroke": "#6f2fa0",
            "fill": "#dbcbe7",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "babcc47d85abbf84",
            "42fdce6627e1c84a",
            "e852d3c25ec22203",
            "6aced2a29121cd5b",
            "81373ddc3e3422b4"
        ],
        "x": 24,
        "y": 139,
        "w": 682,
        "h": 142
    },
    {
        "id": "d39199becfb613a9",
        "type": "group",
        "z": "5cc5759c4e59a5b9",
        "name": "Uplink",
        "style": {
            "label": true,
            "color": "#000000",
            "fill": "#e3f3d3"
        },
        "nodes": [
            "81154890f2e51b22",
            "55a952dc1c25cdd0",
            "89faa192f420e27a"
        ],
        "x": 740,
        "y": 79,
        "w": 352,
        "h": 222
    },
    {
        "id": "cf0f4185b7b366fc",
        "type": "group",
        "z": "5cc5759c4e59a5b9",
        "name": "Downlink",
        "style": {
            "fill": "#e3f3d3",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "20b0f415e9930935",
            "a5401e06829c3a0b",
            "3b6a508a2d151aae",
            "f1b1bfe47902473c",
            "3fdb4c339c670156",
            "37625d0e5293d94f",
            "3770a2d7b36f50bb",
            "6d24d636d121f3ca",
            "82c973a25a9fff5f",
            "63bb78783744a097",
            "d66b2fc77c914ef1"
        ],
        "x": 1114,
        "y": 79,
        "w": 932,
        "h": 222
    },
    {
        "id": "ad4aaedc86729471",
        "type": "group",
        "z": "5cc5759c4e59a5b9",
        "name": "polling of class C devices's downlink bacnet objects",
        "style": {
            "stroke": "#ffC000",
            "fill": "#ffefbf",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "9b85152b47c16eb0",
            "d00282e8150bf0bd",
            "da83a8fbb75177d9",
            "940fec9018446d96",
            "79e3086f522954f1",
            "f9accd901cfb1adf",
            "f8bce9cacf1c7e16",
            "cdbf6221de3e6198",
            "7a200378e7bc7755",
            "c0d116b23c19852f",
            "54f5534c655aa398"
        ],
        "x": 24,
        "y": 619,
        "w": 1382,
        "h": 182
    },
    {
        "id": "87884948644d31d9",
        "type": "group",
        "z": "5cc5759c4e59a5b9",
        "name": "MQTT send downlink",
        "style": {
            "stroke": "#6f2fa0",
            "fill": "#dbcbe7",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "38c1f757a9590ea9",
            "38dc8c62dcc76251",
            "39818c1b22452bed",
            "a559a39cd7574fab",
            "02228be706349069",
            "95b76c27610df7c7",
            "23302f7da6ac348f"
        ],
        "x": 24,
        "y": 399,
        "w": 722,
        "h": 142
    },
    {
        "id": "403d2b7b7f27eaab",
        "type": "group",
        "z": "5cc5759c4e59a5b9",
        "name": "Error handling",
        "style": {
            "stroke": "#ff0000",
            "fill": "#ffbfbf",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "91a6d3be5cc29a58",
            "2672c46a814535c9",
            "6d467d750a6fb9b9",
            "cd6eb225595d17b3",
            "51649d38f610b411",
            "d5079b16928ea8f4",
            "d54c86c0295989c9",
            "de44e5b3194f58ab",
            "f65871545cbfa045",
            "300303076a0c87d2",
            "73172af1e339dd33",
            "f53279ccc6e6c1b4",
            "6d3a7829e3e402e9",
            "05c8d8e553e7b93c",
            "ba5c69dff97964d6",
            "7f740ef6194bf32a",
            "b320b88a63df2793",
            "2f3f132843034187",
            "c17ded1dd0e7ad6b",
            "4c4bc0ee5a41d05f",
            "83c3210d6af69f2a",
            "395810ba2850e941",
            "44f453239caa5eac",
            "4f919cc79b35d6f1",
            "a27cbfe63e5a81c3",
            "cbfaa875d5a7e005"
        ],
        "x": 24,
        "y": 839,
        "w": 1162,
        "h": 482
    },
    {
        "id": "f1b1bfe47902473c",
        "type": "junction",
        "z": "5cc5759c4e59a5b9",
        "g": "cf0f4185b7b366fc",
        "x": 1520,
        "y": 180,
        "wires": [
            [
                "20b0f415e9930935",
                "d66b2fc77c914ef1"
            ]
        ]
    },
    {
        "id": "4557805db1b70fbb",
        "type": "junction",
        "z": "5cc5759c4e59a5b9",
        "x": 720,
        "y": 190,
        "wires": [
            [
                "e49c2787445a9854",
                "55a952dc1c25cdd0",
                "81154890f2e51b22",
                "89faa192f420e27a"
            ]
        ]
    },
    {
        "id": "3fdb4c339c670156",
        "type": "junction",
        "z": "5cc5759c4e59a5b9",
        "g": "cf0f4185b7b366fc",
        "x": 1780,
        "y": 180,
        "wires": [
            [
                "a5401e06829c3a0b",
                "6d24d636d121f3ca"
            ]
        ]
    },
    {
        "id": "37625d0e5293d94f",
        "type": "junction",
        "z": "5cc5759c4e59a5b9",
        "g": "cf0f4185b7b366fc",
        "x": 1420,
        "y": 260,
        "wires": [
            [
                "f1b1bfe47902473c",
                "3b6a508a2d151aae"
            ]
        ]
    },
    {
        "id": "3770a2d7b36f50bb",
        "type": "junction",
        "z": "5cc5759c4e59a5b9",
        "g": "cf0f4185b7b366fc",
        "x": 1480,
        "y": 120,
        "wires": [
            [
                "f1b1bfe47902473c",
                "3b6a508a2d151aae"
            ]
        ]
    },
    {
        "id": "95b76c27610df7c7",
        "type": "junction",
        "z": "5cc5759c4e59a5b9",
        "g": "87884948644d31d9",
        "x": 100,
        "y": 480,
        "wires": [
            [
                "02228be706349069",
                "38dc8c62dcc76251"
            ]
        ]
    },
    {
        "id": "cdbf6221de3e6198",
        "type": "junction",
        "z": "5cc5759c4e59a5b9",
        "g": "ad4aaedc86729471",
        "x": 920,
        "y": 700,
        "wires": [
            [
                "da83a8fbb75177d9"
            ]
        ]
    },
    {
        "id": "395810ba2850e941",
        "type": "junction",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "x": 640,
        "y": 960,
        "wires": [
            [
                "c17ded1dd0e7ad6b"
            ]
        ]
    },
    {
        "id": "54f5534c655aa398",
        "type": "junction",
        "z": "5cc5759c4e59a5b9",
        "g": "ad4aaedc86729471",
        "x": 388.57142857142856,
        "y": 700,
        "wires": [
            [
                "79e3086f522954f1"
            ]
        ]
    },
    {
        "id": "6aced2a29121cd5b",
        "type": "junction",
        "z": "5cc5759c4e59a5b9",
        "g": "61078575c808c2ab",
        "x": 255,
        "y": 200,
        "wires": [
            [
                "42fdce6627e1c84a",
                "81373ddc3e3422b4"
            ]
        ]
    },
    {
        "id": "23302f7da6ac348f",
        "type": "junction",
        "z": "5cc5759c4e59a5b9",
        "g": "87884948644d31d9",
        "x": 430,
        "y": 500,
        "wires": [
            [
                "38c1f757a9590ea9",
                "a559a39cd7574fab"
            ]
        ]
    },
    {
        "id": "e49c2787445a9854",
        "type": "debug",
        "z": "5cc5759c4e59a5b9",
        "name": "Debug \"device\" object",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 840,
        "y": 60,
        "wires": []
    },
    {
        "id": "81373ddc3e3422b4",
        "type": "function",
        "z": "5cc5759c4e59a5b9",
        "g": "61078575c808c2ab",
        "name": "Create Device Object (On Start TO CONFIGURE)",
        "func": "let deviceList = flow.get('g_deviceList');\nlet networkServer;\nlet deviceName, deviceType, deviceNum, devEUI, topicDownlink;\nlet devicePayload = {};\nlet previousValues = flow.get(\"g_previousValues\");\n\nlet topicUp = msg.topic;\n\n// Guess the NetworkServer from the received frame\nif (msg.payload.hasOwnProperty('deviceInfo'))       networkServer = \"chirpstack\";\nif (msg.payload.hasOwnProperty('end_device_ids'))   networkServer = \"tts\";\nif (msg.payload.hasOwnProperty('DevEUI_uplink'))    networkServer = \"actility\";\nif (msg.payload.hasOwnProperty('dc'))               networkServer = \"helium\";\n\n// Reject messages from Actility :\nif ( 'DevEUI_notification' in msg.payload || 'DevEUI_notification' in msg.payload)  return null;\nif ( 'DevEUI_downlink_Rejected' in msg.payload) {\n    node.error(\"Actility : Downlink Message Rejected\");\n    return null;\n}\n\n//////////////////////////////////////////////////////////////////////////\n// The Things Stack Network Server \n/////////////////////////////////////////////////////////////////////////\n\nif (networkServer == \"tts\") {\n    deviceName = msg.payload.end_device_ids.device_id;\n    topicDownlink = topicUp.replace(flow.get('g_tts_topicUplinkSuffix'), \"\") + flow.get('g_tts_topicDownlinkSuffix');\n    devEUI = msg.payload.end_device_ids.dev_eui;\n    if (!Object.keys(msg.payload.uplink_message).some(element => element == \"decoded_payload\")) {\n        node.error(deviceName + \" : No payload decoder configured on the Network Server\");\n        return null;\n    }\n    devicePayload = msg.payload.uplink_message.decoded_payload;\n}\n\n//////////////////////////////////////////////////////////////////////////\n// Helium Network Server \n/////////////////////////////////////////////////////////////////////////\n\nif (networkServer == \"helium\") {\n    deviceName = msg.payload.name;\n    topicDownlink = topicUp.replace(flow.get('g_helium_topicUplinkSuffix'), \"\") + flow.get('g_helium_topicDownlinkSuffix');\n    devEUI = msg.payload.dev_eui;\n    if (msg.payload.decoded.status == \"empty\") {\n        node.error(deviceName + \" : No payload decoder configured on the Network Server\");\n        return null;\n    }\n    devicePayload = msg.payload.decoded.payload;\n}\n//////////////////////////////////////////////////////////////////////////\n// Chirpstack Network Server \n/////////////////////////////////////////////////////////////////////////\n\nif (networkServer == \"chirpstack\") {\n    if (msg.payload.fPort == 0) return 0;\n    deviceName = msg.payload.deviceInfo.deviceName;\n    topicDownlink = topicUp.replace(flow.get('g_chirp_topicUplinkSuffix'), \"\") + flow.get('g_chirp_topicDownlinkSuffix');\n    devEUI = msg.payload.deviceInfo.devEui;\n    if (!Object.keys(msg.payload).some(element => element == \"object\")) {\n        node.error(deviceName + \" : No payload decoder configured on the Network Server\");\n        return null;\n    }\n    devicePayload = msg.payload.object;\n}\n\n//////////////////////////////////////////////////////////////////////////\n// Actility Network Server \n/////////////////////////////////////////////////////////////////////////\n\nif (networkServer == \"actility\") {\n    deviceName = msg.payload.DevEUI_uplink.CustomerData.name;\n    topicDownlink = topicUp.replace(flow.get('g_actility_topicUplinkSuffix'), \"\") + flow.get('g_actility_topicDownlinkSuffix');\n    devEUI = msg.payload.DevEUI_uplink.DevEUI;\n    if (!Object.keys(msg.payload.DevEUI_uplink).some(element => element == \"payload\")) {\n        node.error(deviceName + \" : No payload decoder configured on the Network Server\");\n        return null;\n    }\n    devicePayload = msg.payload.DevEUI_uplink.payload;\n}\n\n//////////////////////////////////////////////////////////////////////////\n// Checks\n/////////////////////////////////////////////////////////////////////////\nconst match = deviceName.match(/^(.*)-(\\d+)$/);\nif (match) {\n    deviceType = match[1];  // The part before the last dash\n    deviceNum = parseInt(match[2], 10);  // The number at the end, converted to an integer\n}\nelse {\n    node.error(\"Error: Device Name does not respect *xxx - num* format\",\n                {\n                    errorType: \"deviceName\",\n                    value: deviceName,\n                });\n    return null;\n}\n\nif ((deviceNum == 0)) {\n    node.error('Error: Device Num is 0 is not allowed',\n        {\n            errorType: \"deviceName\",\n            value: deviceName,\n        });\n    return null;\n}\n\nif (deviceList[deviceType] == undefined) {\n    node.error('Error: Device Type does not belong to the Device List',\n        {\n            errorType: \"deviceName\",\n            value: deviceName,\n        });\n    return null;\n}\n\n// Check deviceNum overflow\nif (deviceNum > deviceList[deviceType].identity.maxDevNum) {\n    node.error('Error: Device number is too high',\n        {\n            errorType: \"deviceName\",\n            value: deviceName,\n        });\n    return null;\n}\n\n//////////////////////////////////////////////////////////////////////////\n// Create a copy of the \"deviceType\" object of the \"deviceList\" structure\n/////////////////////////////////////////////////////////////////////////\nlet device = JSON.parse(JSON.stringify(deviceList[deviceType]));\n\ndevice.identity.deviceName = deviceName;\ndevice.identity.deviceType = deviceType;\ndevice.identity.deviceNum = deviceNum;\ndevice.identity.devEUI = devEUI;\ndevice.mqtt.topicDownlink = topicDownlink;\n\nfor (let object in device.bacnet.objects) {\n    // Update instanceNum\n    switch (device.bacnet.objects[object].assignementMode) {\n        case \"manual\":\n            \n            break;\n        case \"auto\":\n            switch (device.bacnet.objects[object].objectType) {\n                case \"analogValue\":\n                    device.bacnet.objects[object].instanceNum += device.bacnet.offsetAV + (device.bacnet.instanceRangeAV * deviceNum);\n                    break;\n                case \"binaryValue\":\n                    device.bacnet.objects[object].instanceNum += device.bacnet.offsetBV + (device.bacnet.instanceRangeBV * deviceNum);\n                    break;\n                default:\n                    node.error(\"Object type of \" + object + \" is unknown : \" + device.bacnet.objects[object].objectType);\n                    return null;\n                    \n            }\n            break;\n        default:\n            \n    }\n\n    // Update objectName\n    device.bacnet.objects[object].objectName = deviceName + '-' + object + '-' + device.bacnet.objects[object].instanceNum;\n    // Update value\n    if (device.bacnet.objects[object].dataDirection == \"uplink\") {\n        let lorawanPayloadName = device.bacnet.objects[object].lorawanPayloadName;\n        let keys = lorawanPayloadName.split(/[\\.\\[\\]]/).filter(key => key !== \"\");\n        let value = keys.reduce((accumulator, currentValue) => accumulator[currentValue], devicePayload);\n        device.bacnet.objects[object].value = value;\n    }\n    // Check value\n    if (device.bacnet.objects[object].value == undefined || typeof device.bacnet.objects[object].value == \"object\") {\n        node.error(`Device : ${device.identity.deviceName} - Object : ${object} - Wrong Payload decoder or Wrong Device description`);\n        return null;\n    }\n\n    if (device.controller.protocol == \"bacnet\") {\n        // \"restAPIBacnet\" and \"bacnet\" compatibility \n        switch (device.bacnet.objects[object].objectType) {\n            case \"analogValue\": device.bacnet.objects[object].objectType = 2; break;\n            case \"binaryValue\": device.bacnet.objects[object].objectType = 5; break;\n        }\n        // Keep only uplink payload in a new object\n        device.bacnet.uplinkKeys = Object.entries(device.bacnet.objects)\n            .filter(([key, obj]) => obj.dataDirection === \"uplink\")\n            .map(([key, obj]) => key);\n    }\n}\n\n// For debug\ndevice.transmitTime = Date.now();\n\n// For InfluxDB support\ndevice.influxdb = {\n    \"source\": \"uplink\"\n};\n// To save previous values\nif (!previousValues.hasOwnProperty(device.identity.deviceName)){\n    \n    previousValues[device.identity.deviceName] = RED.util.cloneMessage(device);\n    \n}\n\nreturn {\n    \"device\": device\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "/////////////////////////////////////////////////////\n////////////    TO CONFIGURE      ///////////////////\n/////////////////////////////////////////////////////\n\nconst heliumDownlinkSuffix = \"TO_CONFIGURE\";\nconst heliumUplinkSuffix = \"TO_CONFIGURE\";\n\n// configuration.js files (on GitHub) provides   //\n// examples of deviceList configuration          //\n\nlet deviceList = {\n    \n\n\n    \n}\n/////////////////////////////////////////////////\n/////////////   DO NOT MODIFY ///////////////////\n/////////////////////////////////////////////////\n\nconst networkServerSupported = [\"tts\", \"chirpstack\", \"actility\", \"helium\"];\nconst downlinkStrategies = [\"compareToUplinkObject\", \"compareToUplinkObjectWithinRange\", \"onChangeOfThisValue\", \"onChangeOfThisValueWithinRange\"];\nconst protocolSupported = [\"restAPIBacnet\", \"bacnet\"];\n\n// Store flow variables\nflow.set('g_httpRequestTimeOut', 5000);\nflow.set('g_tts_topicDownlinkSuffix', \"/down\");\nflow.set('g_tts_topicUplinkSuffix', \"/up\");\nflow.set('g_chirp_topicDownlinkSuffix', \"/command/down\");\nflow.set('g_chirp_topicUplinkSuffix', \"/event/up\");\nflow.set('g_actility_topicDownlinkSuffix', \"/downlink\");\nflow.set('g_actility_topicUplinkSuffix', \"/uplink\");\nflow.set('g_helium_topicDownlinkSuffix', heliumDownlinkSuffix);\nflow.set('g_helium_topicUplinkSuffix', heliumUplinkSuffix);\nif (flow.get(\"g_previousValues\") === undefined) {\n    flow.set(\"g_previousValues\", {});\n}\n\n// Debug function\nconst debug = function (device, debugType, debugText) {\n    if (debugType == \"forceOn\") {\n        node.warn(debugText);\n    }\n    else if (device.controller.debug.some(element => element == \"all\" || element == debugType)) {\n        node.warn(debugText);\n    }\n    else {\n        return null;\n    }\n}\nflow.set(\"g_debug\", debug);\n\n// Controller HTTP Autentification key\nfor (let device in deviceList) {\n    const buffer = Buffer.from(deviceList[device].controller.login + ':' + deviceList[device].controller.password);\n    deviceList[device].controller.httpAuthentication = \"Basic \" + buffer.toString('base64');\n}\n\n////////////////////////////////\n// Check configuration settings\n////////////////////////////////\nlet objectInstanceArrayAV = [], objectInstanceArrayBV = [];\nlet maxDevNumAV, maxDevNumBV;\n\nfor (let device in deviceList) {\n\n    // Add \"identity\" and \"mqtt\" properties\n    deviceList[device].mqtt = {};\n\n    // Check LoRaWAN Network Servers [\"tts\", \"chirpstack\", \"actility\"]\n    if (!networkServerSupported.some(element => element == deviceList[device].lorawan.networkServer)) {\n        node.error(\"Error Unknow network server\",\n            {\n                errorType: \"deviceListLoRaWANConfiguration\",\n                device: device,\n                property: \"networkServer\",\n                value: deviceList[device].lorawan.networkServer\n            });\n\n        node.status({ fill: \"red\", shape: \"dot\", text: \"Network Server not supported\" });\n        return null;\n    }\n\n    // Check that bacnetObject had every necessary properties\n    for (let object in deviceList[device].bacnet.objects) {\n        if (!deviceList[device].bacnet.objects[object].hasOwnProperty(\"lorawanPayloadName\")) {\n            node.error(\"Error missing object property\",\n                {\n                    errorType: \"deviceListBACnetObjectConfigurationMissingProperty\",\n                    device: device,\n                    object: object,\n                    property: \"lorawanPayloadName\"\n                });\n            node.status({ fill: \"red\", shape: \"dot\", text: \"Missing object property\" });\n            return null;\n        } else if (!deviceList[device].bacnet.objects[object].hasOwnProperty(\"objectType\")) {\n            node.error(\"Error missing object property\",\n                {\n                    errorType: \"deviceListBACnetObjectConfigurationMissingProperty\",\n                    device: device,\n                    object: object,\n                    property: \"objectType\"\n                });\n            node.status({ fill: \"red\", shape: \"dot\", text: \"Missing object property\" });\n            return null;\n        } else if (!deviceList[device].bacnet.objects[object].hasOwnProperty(\"assignementMode\")) {\n            node.error(\"Error missing object property\",\n                {\n                    errorType: \"deviceListBACnetObjectConfigurationMissingProperty\",\n                    device: device,\n                    object: object,\n                    property: \"assignementMode\"\n                });\n            node.status({ fill: \"red\", shape: \"dot\", text: \"Missing object property\" });\n            return null;\n        } else if (!deviceList[device].bacnet.objects[object].hasOwnProperty(\"instanceNum\")) {\n            node.error(\"Error missing object property\",\n                {\n                    errorType: \"deviceListBACnetObjectConfigurationMissingProperty\",\n                    device: device,\n                    object: object,\n                    property: \"instanceNum\"\n                });\n            node.status({ fill: \"red\", shape: \"dot\", text: \"Missing object property\" });\n            return null;\n        } else if (!deviceList[device].bacnet.objects[object].hasOwnProperty(\"dataDirection\")) {\n            node.error(\"Error missing object property\",\n                {\n                    errorType: \"deviceListBACnetObjectConfigurationMissingProperty\",\n                    device: device,\n                    object: object,\n                    property: \"dataDirection\"\n                });\n            node.status({ fill: \"red\", shape: \"dot\", text: \"Missing object property\" });\n            return null;\n        } else if (!deviceList[device].bacnet.objects[object].hasOwnProperty(\"value\")) {\n            node.error(\"Error missing object property\",\n                {\n                    errorType: \"deviceListBACnetObjectConfigurationMissingProperty\",\n                    device: device,\n                    object: object,\n                    property: \"value\"\n                });\n            node.status({ fill: \"red\", shape: \"dot\", text: \"Missing object property\" });\n            return null;\n        } else if (deviceList[device].bacnet.objects[object].dataDirection === \"downlink\") {\n\n            if (!deviceList[device].bacnet.objects[object].hasOwnProperty(\"downlinkPort\")) {\n                node.error(\"Error missing object property\",\n                    {\n                        errorType: \"deviceListBACnetObjectConfigurationMissingProperty\",\n                        device: device,\n                        object: object,\n                        property: \"downlinkPort\"\n                    });\n                node.status({ fill: \"red\", shape: \"dot\", text: \"Missing object property\" });\n                return null;\n            } else if (!deviceList[device].bacnet.objects[object].hasOwnProperty(\"downlinkPortPriority\")) {\n                node.error(\"Error missing object property\",\n                    {\n                        errorType: \"deviceListBACnetObjectConfigurationMissingProperty\",\n                        device: device,\n                        object: object,\n                        property: \"downlinkPortPriority\"\n                    });\n                node.status({ fill: \"red\", shape: \"dot\", text: \"Missing object property\" });\n                return null;\n            } else if (!deviceList[device].bacnet.objects[object].hasOwnProperty(\"downlinkStrategie\")) {\n                node.error(\"Error missing object property\",\n                    {\n                        errorType: \"deviceListBACnetObjectConfigurationMissingProperty\",\n                        device: device,\n                        object: object,\n                        property: \"downlinkStrategie\"\n                    });\n                node.status({ fill: \"red\", shape: \"dot\", text: \"Missing object property\" });\n                return null;\n            } else if (!downlinkStrategies.some(element => element == deviceList[device].bacnet.objects[object].downlinkStrategie)){\n                node.error(\"Error incorrect downlink strategie\",\n                    {\n                        errorType: \"deviceListBACnetObjectConfiguration\",\n                        device: device,\n                        property: \"downlinkStrategie\",\n                        object: object,\n                        value: deviceList[device].bacnet.objects[object].downlinkStrategie,\n                    });\n                node.status({ fill: \"red\", shape: \"dot\", text: \"incorrect downlink strategie\" });\n\n            } else if (deviceList[device].bacnet.objects[object].downlinkStrategie === \"compareToUplinkObject\" || deviceList[device].bacnet.objects[object].downlinkStrategie === \"compareToUplinkObjectWithinRange\") {\n\n                if (!deviceList[device].bacnet.objects[object].hasOwnProperty(\"uplinkObjectToCompareWith\")) {\n                    node.error(\"Error missing object property\",\n                        {\n                            errorType: \"deviceListBACnetObjectConfigurationMissingProperty\",\n                            device: device,\n                            object: object,\n                            property: \"uplinkObjectToCompareWith\"\n                        });\n                    node.status({ fill: \"red\", shape: \"dot\", text: \"Missing object property\" });\n                    return null;\n                } else if (!deviceList[device].bacnet.objects[object].hasOwnProperty(\"range\") && deviceList[device].bacnet.objects[object].downlinkStrategie === \"compareToUplinkObjectWithinRange\"){\n                    node.error(\"Error missing object property\",\n                        {\n                            errorType: \"deviceListBACnetObjectConfigurationMissingProperty\",\n                            device: device,\n                            object: object,\n                            property: \"range\"\n                        });\n                    node.status({ fill: \"red\", shape: \"dot\", text: \"Missing object property\" });\n                    return null ;\n                } else if ((deviceList[device].bacnet.objects[object].range?.length != 2 || deviceList[device].bacnet.objects[object].range[1] < deviceList[device].bacnet.objects[object].range[0]) && deviceList[device].bacnet.objects[object].downlinkStrategie === \"compareToUplinkObjectWithinRange\") {\n                    node.error(\"Error incorrect Range\",\n                        {\n                            errorType: \"deviceListBACnetObjectConfiguration\",\n                            device: device,\n                            property: \"range\",\n                            object: object,\n                            value: deviceList[device].bacnet.objects[object].range,\n                        });\n                    node.status({ fill: \"red\", shape: \"dot\", text: \"incorrect range\" });\n                    return null;\n                }\n            } else if (deviceList[device].bacnet.objects[object].downlinkStrategie === \"onChangeOfThisValueWithinRange\") {\n                if (!deviceList[device].bacnet.objects[object].hasOwnProperty(\"range\")) {\n                    node.error(\"Error missing object property\",\n                        {\n                            errorType: \"deviceListBACnetObjectConfigurationMissingProperty\",\n                            device: device,\n                            property: \"range\"\n                        });\n                    node.status({ fill: \"red\", shape: \"dot\", text: \"Missing object property\" });\n                    return null;\n                } else if (deviceList[device].bacnet.objects[object].range.length != 2 || deviceList[device].bacnet.objects[object].range[1] < deviceList[device].bacnet.objects[object].range[0]) {\n                    node.error(\"Error incorrect range\",\n                        {\n                            errorType: \"deviceListBACnetObjectConfiguration\",\n                            device: device,\n                            property: \"range\",\n                            object: object,\n                            value: deviceList[device].bacnet.objects[object].range,\n                        });\n                    node.status({ fill: \"red\", shape: \"dot\", text: \"incorrect range\" });\n                    return null;\n                }\n            }\n        }\n    }\n\n    // Check device.controller.protocol [\"restAPIBacnet\", \"bacnet\"]\n    if (!protocolSupported.some(element => element == deviceList[device].controller.protocol)) {\n        node.error(\"Error Unknow controller protocol\",\n            {\n                errorType: \"deviceListControllerConfiguration\",\n                device: device,\n                property: \"protocol\",\n                value: deviceList[device].controller.protocol\n            });\n        node.status({ fill: \"red\", shape: \"dot\", text: \"Controller protocol not supported\" });\n        return null;\n    }\n\n    // Check device.bacnet.instanceRange >= Number of BACnet object in the deviceList\n    let instanceRangeAV = 0, instanceRangeBV = 0;\n    let assignementMode = null;\n\n    for (let object in deviceList[device].bacnet.objects) {\n        if (assignementMode === null) {\n            assignementMode = deviceList[device].bacnet.objects[object].assignementMode\n        } else if (assignementMode != deviceList[device].bacnet.objects[object].assignementMode) {\n            node.error(\"Error Objects have different assignement mode\",\n                {\n                    errorType: \"deviceListBACnetObjectConfiguration\",\n                    device: device,\n                    property: \"assignementMode\",\n                    object: object,\n                    objectType: \"any\",\n                    value: deviceList[device].bacnet.objects[object].assignementMode,\n                });\n            node.status({ fill: \"red\", shape: \"dot\", text: object + \" different assignement mode\" });\n            return null\n        }\n        switch (deviceList[device].bacnet.objects[object].objectType) {\n            case \"analogValue\":\n                if (deviceList[device].bacnet.objects[object].instanceNum >= deviceList[device].bacnet.instanceRangeAV && deviceList[device].bacnet.objects[object].assignementMode != \"manual\") {\n                    node.error(\"Error InstanceNum too high\",\n                        {\n                            errorType: \"deviceListBACnetObjectConfiguration\",\n                            device: device,\n                            property: \"instanceNum\",\n                            object: object,\n                            objectType: \"analog value\",\n                            value: deviceList[device].bacnet.objects[object].instanceNum,\n                        });\n                    node.status({ fill: \"red\", shape: \"dot\", text: object + \" instanceNum too high\" });\n                    return null;\n                } else {\n                    instanceRangeAV++;\n                }\n                break;\n            case \"binaryValue\":\n                if (deviceList[device].bacnet.objects[object].instanceNum >= deviceList[device].bacnet.instanceRangeBV && deviceList[device].bacnet.objects[object].assignementMode != \"manual\") {\n                    node.error(\"Error InstanceNum too high\",\n                        {\n                            errorType: \"deviceListBACnetObjectConfiguration\",\n                            device: device,\n                            property: \"instanceNum\",\n                            object: object,\n                            objectType: \"binary value\",\n                            value: deviceList[device].bacnet.objects[object].instanceNum,\n                        });\n                    node.status({ fill: \"red\", shape: \"dot\", text: object + \" instanceNum too high\" });\n                    return null;\n                } else {\n                    instanceRangeBV++;\n                }\n                break;\n            default:\n\n        }\n        if (deviceList[device].bacnet.objects[object].instanceNum < 0) {\n            node.error(\"Error Negative instanceNum\",\n                {\n                    errorType: \"deviceListBACnetObjectConfiguration\",\n                    device: device,\n                    property: \"instanceNum\",\n                    object: object,\n                    objectType: \"any\",\n                    value: deviceList[device].bacnet.objects[object].instanceNum\n                });\n            node.status({ fill: \"red\", shape: \"dot\", text: object + \"Negative instanceNum\" });\n            return null;\n        }\n    }\n    if (deviceList[device].bacnet.instanceRangeAV < instanceRangeAV) {\n        node.error(\"Error InstanceRange too small\",\n            {\n                errorType: \"deviceListBACnetConfiguration\",\n                device: device,\n                property: \"instanceRangeAV\",\n                value: deviceList[device].bacnet.instanceRangeAV,\n            });\n        node.status({ fill: \"red\", shape: \"dot\", text: \"InstanceRange too small\" });\n        return null;\n    }\n    if (deviceList[device].bacnet.instanceRangeBV < instanceRangeBV) {\n        node.error(\"Error InstanceRange too small\",\n            {\n                errorType: \"deviceListBACnetConfiguration\",\n                device: device,\n                property: \"instanceRangeBV\",\n                value: deviceList[device].bacnet.instanceRangeBV,\n            });\n        node.status({ fill: \"red\", shape: \"dot\", text: \"InstanceRange too small\" });\n        return null;\n    }\n\n    // Build an array with offsetAV, instanceRangeAV, maxDeviceNum and device\n    objectInstanceArrayAV.push({ \"device\": device, \"offset\": deviceList[device].bacnet.offsetAV, \"instanceRange\": deviceList[device].bacnet.instanceRangeAV, \"maxdevNum\": deviceList[device].identity.maxDevNum });\n    // Build another array with offsetAV, instanceRangeBV, instanceRangeAV and device\n    objectInstanceArrayBV.push({ \"device\": device, \"offset\": deviceList[device].bacnet.offsetBV, \"instanceRange\": deviceList[device].bacnet.instanceRangeBV, \"maxdevNum\": deviceList[device].identity.maxDevNum });\n}\n\n// Check that offset and instanceRange don't overlap and that there is not any manual object in another device object instance range.\nobjectInstanceArrayAV.sort((a, b) => a.offset - b.offset);\nobjectInstanceArrayBV.sort((a, b) => a.offset - b.offset);\nfor (let i = 0; i < objectInstanceArrayAV.length - 1; i++) {\n    if (objectInstanceArrayAV[i].instanceRange != 0) {\n\n        if (objectInstanceArrayAV[i].offset + objectInstanceArrayAV[i].instanceRange * objectInstanceArrayAV[i].maxdevNum > objectInstanceArrayAV[i + 1].offset) {\n            node.error(\"Error Analog values BACnet objects of devices overlap\",\n                {\n                    errorType: \"deviceListOverlap\",\n                    device1: objectInstanceArrayAV[i].device,\n                    device2: objectInstanceArrayAV[i + 1].device,\n                });\n            node.status({ fill: \"red\", shape: \"dot\", text: \"BACnet objects instances overlap\" });\n            return null;\n        }\n\n    }\n    if (objectInstanceArrayBV[i].instanceRange != 0) {\n        if (objectInstanceArrayBV[i].offset + objectInstanceArrayBV[i].instanceRange * objectInstanceArrayBV[i].maxdevNum > objectInstanceArrayBV[i + 1].offset) {\n            node.error(\"Error Binary values BACnet objects of devices overlap\",\n                {\n                    errorType: \"deviceListOverlap\",\n                    device1: objectInstanceArrayBV[i].device,\n                    device2: objectInstanceArrayBV[i + 1].device,\n                });\n            node.status({ fill: \"red\", shape: \"dot\", text: \"BACnet objects instances overlap\" });\n            return null;\n        }\n\n    }\n}\n\n////////////////////////////////////\n// Return if all checkings are clear\n///////////////////////////////////\nnode.status({ fill: \"green\", shape: \"dot\", text: \"Configuration OK\" });\nflow.set('g_deviceList', deviceList)\n\nnode.send(deviceList);\n\n",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 180,
        "wires": [
            [
                "4557805db1b70fbb"
            ]
        ],
        "icon": "node-red/switch.svg"
    },
    {
        "id": "babcc47d85abbf84",
        "type": "mqtt in",
        "z": "5cc5759c4e59a5b9",
        "g": "61078575c808c2ab",
        "name": "MQTT Subscriber",
        "topic": "application/+/device/+/event/up",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "f75024a426208b8a",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 130,
        "y": 180,
        "wires": [
            [
                "6aced2a29121cd5b"
            ]
        ],
        "info": "\r\n# MQTT Subscriber node\r\n\r\n - How to configure this node\r\n    -\r\n    The configuration off this node depend of which LNS or MQTT broker you use.\r\n\r\n    - For The Things Network\r\n        - \r\n        With **TTN LNS** you have to use the following topic :\r\n            ***`v3/{application_id}@ttn/devices/+/up`*** \\\r\n        Replace `{application_id}` by your application id in TTN.\\\r\n         And don't forget the `@ttn`\r\n    - For The Things Stack\r\n        - \r\n        With **TTS LNS** you have to use the following topic :\r\n            ***`v3/{application_id}/devices/+/up`*** \\\r\n        Replace `{application_id}` by your application id in TTS.\r\n\r\n    - For Chirpstack\r\n        - \r\n        With **Chirpstack LNS** you have to use the following topic :\r\n            ***`application/{application_id}/device/+/event/up`*** \\\r\n        Replace `{application_id}` by your application id (it's the number, not the name !).\r\n    - For Actility\r\n        - \r\n        if you use **Actility LNS** see the [documentation](https://docs.thingpark.com/thingpark-x/latest/Connector/BROKER_MQTT/) for using actillity broker\r\n\r\n        - For actility-USMB Broker : ***`univ-smb/devices/+/uplink`***\r\n        - For HiveMQ Broker : ***`mqtt/things/+/uplink`***\r\n        \r\n    - For other LNS or MQTT broker\r\n        - \r\n        If you use any other LNS or MQTT broker please refer to their documentation to configure this MQTT node."
    },
    {
        "id": "a559a39cd7574fab",
        "type": "mqtt out",
        "z": "5cc5759c4e59a5b9",
        "g": "87884948644d31d9",
        "name": "MQTT Publisher",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "f75024a426208b8a",
        "x": 560,
        "y": 500,
        "wires": []
    },
    {
        "id": "81154890f2e51b22",
        "type": "subflow:4d0f0c0771ab4500",
        "z": "5cc5759c4e59a5b9",
        "g": "d39199becfb613a9",
        "name": "Rest API Read downlink/Write uplink",
        "x": 916,
        "y": 120,
        "wires": [
            [
                "63bb78783744a097"
            ]
        ]
    },
    {
        "id": "55a952dc1c25cdd0",
        "type": "link out",
        "z": "5cc5759c4e59a5b9",
        "g": "d39199becfb613a9",
        "name": "Write InfluxDB for uplink",
        "mode": "link",
        "links": [],
        "x": 781,
        "y": 190,
        "wires": []
    },
    {
        "id": "20b0f415e9930935",
        "type": "function",
        "z": "5cc5759c4e59a5b9",
        "g": "cf0f4185b7b366fc",
        "name": "Downlink Strategies",
        "func": "///////////////////////////////////////////////////////////\n////// This part is device dependant\n////// The configuration depends on the downlink strategy\n///////////////////////////////////////////////////////////\n\nlet device = msg.device;\nif (device.lorawan.hasOwnProperty(\"defaultValuesForDownlink\")){\n    var staticDownlinkObjects = device.lorawan.defaultValuesForDownlink\n}\nlet bacnetObjects = device.bacnet.objects;\nconst debug = flow.get(\"g_debug\");\nlet downlinkLowPriorityObject = 0;\nlet previousValues = RED.util.cloneMessage(flow.get(\"g_previousValues\"));\nlet previousBacnetObject = previousValues[device.identity.deviceName].bacnet.objects;\nlet payload={};\n\nfunction downlinkPayloadCreation(downlinkObjectToSend) {\n    //Creation of the downlink payload\n    for (let obj in bacnetObjects){\n        if (bacnetObjects[obj].dataDirection === \"downlink\" && bacnetObjects[obj].downlinkPort == bacnetObjects[downlinkObjectToSend].downlinkPort){\n            let temp = \"{ \\\"\" + obj + \"\\\" : \" + JSON.stringify(bacnetObjects[obj].value) + \" }\";                        \n            payload = { ...payload, ...JSON.parse(temp) }\n        }\n    }\n    // Chek if there are other values to add to the payload\n    if (device.lorawan.hasOwnProperty(\"defaultValuesForDownlink\") ){\n        if (device.lorawan.defaultValuesForDownlink.hasOwnProperty(\"fPort_\" + bacnetObjects[downlinkObjectToSend].downlinkPort)){\n            for (let obj in staticDownlinkObjects[\"fPort_\"+ bacnetObjects[downlinkObjectToSend].downlinkPort]){\n                    let temp = \"{ \\\"\" + obj + \"\\\" : \" + JSON.stringify(staticDownlinkObjects[\"fPort_\"+ bacnetObjects[downlinkObjectToSend].downlinkPort][obj]) + \" }\";                        \n                    payload = { ...payload, ...JSON.parse(temp) }\n    \n            }\n        }\n    }\n    msg ={\n        \"payload\" : payload,\n        \"device\" :device\n    }\n    msg.device.lorawan.downlinkPort = bacnetObjects[downlinkObjectToSend].downlinkPort\n                        \n}\n\nfor (let object in bacnetObjects) {\n\n    if (bacnetObjects[object].dataDirection === \"downlink\") {\n        \n        switch (bacnetObjects[object].downlinkPortPriority) {\n            case \"high\":\n                switch (bacnetObjects[object].downlinkStrategie) {\n                    case \"onChangeOfThisValue\":\n                        if (bacnetObjects[object].value != previousBacnetObject[object].value) {\n                            node.status({ fill: \"yellow\", shape: \"dot\", text: \"Downlink high priority COV\" });\n                            debug(device, \"down\", `${device.identity.deviceName} (${device.controller.protocol}) : Downlink scheduled : Previous value ${previousBacnetObject[object].value}  != ${object} ${bacnetObjects[object].value}`);\n                            //Creation of the downlink payload\n                            downlinkPayloadCreation(object)\n                            return msg\n                        }\n                        break;\n                    case \"onChangeOfThisValueWithinRange\":\n                        if (bacnetObjects[object].value != previousBacnetObject[object].value && bacnetObjects[object].value <= bacnetObjects[object].range[1] && bacnetObjects[object].value >= bacnetObjects[object].range[0]) {\n                            node.status({ fill: \"yellow\", shape: \"dot\", text: \"Downlink high priority COVWR\" });\n                            debug(device, \"down\", `${device.identity.deviceName} (${device.controller.protocol}) : Downlink scheduled : Previous value ${previousBacnetObject[object].value}  != ${object} ${bacnetObjects[object].value}`);\n                            //Creation of the downlink payload\n                            downlinkPayloadCreation(object)\n                            return msg\n                        }\n                        break;\n                    case \"compareToUplinkObjectWithinRange\":\n                        if (bacnetObjects[object].value != bacnetObjects[bacnetObjects[object].uplinkObjectToCompareWith].value && bacnetObjects[object].value <= bacnetObjects[object].range[1] && bacnetObjects[object].value >= bacnetObjects[object].range[0]) {\n                            node.status({ fill: \"yellow\", shape: \"dot\", text: \"Downlink high priority CUVWR\" });\n                            debug(device, \"down\", `${device.identity.deviceName} (${device.controller.protocol}) : Downlink scheduled : ${bacnetObjects[object].uplinkObjectToCompareWith} ${bacnetObjects[bacnetObjects[object].uplinkObjectToCompareWith].value}  != ${object} ${bacnetObjects[object].value}`);\n                            //Creation of the downlink payload\n                            downlinkPayloadCreation(object)\n                            return msg\n                        }\n                        break;\n                    case \"compareToUplinkObject\":\n                        if (bacnetObjects[object].value != bacnetObjects[bacnetObjects[object].uplinkObjectToCompareWith].value) {\n                            node.status({ fill: \"yellow\", shape: \"dot\", text: \"Downlink high priority CUV\" });\n                            debug(device, \"down\", `${device.identity.deviceName} (${device.controller.protocol}) : Downlink scheduled : ${bacnetObjects[object].uplinkObjectToCompareWith} ${bacnetObjects[bacnetObjects[object].uplinkObjectToCompareWith].value}  != ${object} ${bacnetObjects[object].value}`);\n                            //Creation of the downlink payload\n                            downlinkPayloadCreation(object)\n                            return msg\n                        }\n                        break;\n                    default:\n                        \n                }\n                \n                break;\n            case \"low\":\n                //In case of low priority downlink the object name is kept till the end of the for loop \n                // to be sur that there is not any high priority downlink to send \n                switch (bacnetObjects[object].downlinkStrategie) {\n                    case \"onChangeOfThisValue\":\n                        if (bacnetObjects[object].value != previousBacnetObject[object].value) {\n                            downlinkLowPriorityObject = object;\n                        }\n                        break;\n                    case \"onChangeOfThisValueWithinRange\":\n                        if (bacnetObjects[object].value != previousBacnetObject[object].value && bacnetObjects[object].value <= bacnetObjects[object].range[1] && bacnetObjects[object].value >= bacnetObjects[object].range[0]) {\n                            downlinkLowPriorityObject = object;\n                        }\n                        break;\n                    case \"compareToUplinkObjectWithinRange\":\n                        if (bacnetObjects[object].value != bacnetObjects[bacnetObjects[object].uplinkObjectToCompareWith].value && bacnetObjects[object].value <= bacnetObjects[object].range[1] && bacnetObjects[object].value >= bacnetObjects[object].range[0]) {\n                            downlinkLowPriorityObject = object;\n                        }\n                        break;\n                    case \"compareToUplinkObject\":\n                        if (bacnetObjects[object].value != bacnetObjects[bacnetObjects[object].uplinkObjectToCompareWith].value) {\n                            downlinkLowPriorityObject = object;\n                        }\n                        break;\n                    default:\n                        \n                }\n                break;\n            default:\n\n        }\n    }\n}\nif (downlinkLowPriorityObject != 0) {\n    node.status({ fill: \"yellow\", shape: \"dot\", text: \"Downlink low priority\" });\n    switch (bacnetObjects[downlinkLowPriorityObject].downlinkStrategie) {\n        case \"onChangeOfThisValue\":\n            debug(device, \"down\", `${device.identity.deviceName} (${device.controller.protocol}) : Downlink scheduled : Previous value ${previousBacnetObject[downlinkLowPriorityObject].value}  != ${downlinkLowPriorityObject} ${bacnetObjects[downlinkLowPriorityObject].value}`);\n            break;\n        case \"onChangeOfThisValueWithinRange\":\n            debug(device, \"down\", `${device.identity.deviceName} (${device.controller.protocol}) : Downlink scheduled : Previous value ${previousBacnetObject[downlinkLowPriorityObject].value}  != ${downlinkLowPriorityObject} ${bacnetObjects[downlinkLowPriorityObject].value}`);\n            break;\n        case \"compareToUplinkObjectWithinRange\":\n            debug(device, \"down\", `${device.identity.deviceName} (${device.controller.protocol}) : Downlink scheduled : ${bacnetObjects[downlinkLowPriorityObject].uplinkObjectToCompareWith} ${bacnetObjects[bacnetObjects[downlinkLowPriorityObject].uplinkObjectToCompareWith].value}  != ${downlinkLowPriorityObject} ${bacnetObjects[downlinkLowPriorityObject].value}`);\n            break;\n        case \"compareToUplinkObject\":\n            debug(device, \"down\", `${device.identity.deviceName} (${device.controller.protocol}) : Downlink scheduled : ${bacnetObjects[downlinkLowPriorityObject].uplinkObjectToCompareWith} ${bacnetObjects[bacnetObjects[downlinkLowPriorityObject].uplinkObjectToCompareWith].value}  != ${downlinkLowPriorityObject} ${bacnetObjects[downlinkLowPriorityObject].value}`);\n            break;\n        default:\n                        \n    }\n    //Creation of the dowlink payload\n    downlinkPayloadCreation(downlinkLowPriorityObject)\n    return msg            \n}else{\n\n    node.status({fill: \"green\", shape: \"dot\" ,text: \"No downlink\"});\n    return null;\n}\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1640,
        "y": 180,
        "wires": [
            [
                "3fdb4c339c670156"
            ]
        ],
        "icon": "node-red/cog.svg"
    },
    {
        "id": "a5401e06829c3a0b",
        "type": "debug",
        "z": "5cc5759c4e59a5b9",
        "g": "cf0f4185b7b366fc",
        "name": "Debug strategie",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1620,
        "y": 240,
        "wires": []
    },
    {
        "id": "38c1f757a9590ea9",
        "type": "debug",
        "z": "5cc5759c4e59a5b9",
        "g": "87884948644d31d9",
        "name": "Debug Downlink message",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 590,
        "y": 440,
        "wires": []
    },
    {
        "id": "3b6a508a2d151aae",
        "type": "link out",
        "z": "5cc5759c4e59a5b9",
        "g": "cf0f4185b7b366fc",
        "name": "Write InfluxDB for downlink",
        "mode": "link",
        "links": [
            "51a8096e9379e878"
        ],
        "x": 1365,
        "y": 190,
        "wires": []
    },
    {
        "id": "38dc8c62dcc76251",
        "type": "function",
        "z": "5cc5759c4e59a5b9",
        "g": "87884948644d31d9",
        "name": "Create Downlink Message",
        "func": "\nlet device = msg.device;\nlet downlinkJson = {};\nconst debug = flow.get('g_debug');\n\n// Modify the downlink object according to the lorawanPayloadName.\n\nfor (let object in msg.payload) {\n    // Don't do any changes if lorawanPayloadName is the same as the BACnet Object name.\n    if (!Object.keys(device.bacnet.objects).some(element => element == device.bacnet.objects[object].lorawanPayloadName)) {\n        msg.payload[device.bacnet.objects[object].lorawanPayloadName] = msg.payload[object];\n        delete msg.payload[object];\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n// The Things Stack Network Server \n/////////////////////////////////////////////////////////////////////////\nif (device.lorawan.networkServer == \"tts\") {\n    downlinkJson = {\n        \"topic\": device.mqtt.topicDownlink + (device.lorawan.flushDownlinkQueue ? \"/replace\" : \"/push\"),\n        \"payload\": {\n            \"downlinks\": [\n                {\n                    \"f_port\": device.lorawan.downlinkPort,\n                    \"decoded_payload\": msg.payload,\n                    \"priority\": \"NORMAL\"\n                },\n            ]\n        }\n    }\n    debug(device, \"txTime\", `${device.identity.deviceName} (${device.controller.protocol}) : TX time = ${Date.now() - device.transmitTime} ms`);\n    return downlinkJson;\n}\n//////////////////////////////////////////////////////////////////////////\n// The Things Stack Network Server \n/////////////////////////////////////////////////////////////////////////\nif (device.lorawan.networkServer == \"helium\") {\n    downlinkJson = {\n        \"topic\": device.mqtt.topicDownlink,\n        \"payload\": {\n            \"payload_raw\": \"SGVsbG8sIHdvcmxkIQ==\",\n            \"port\": device.lorawan.downlinkPort,\n            \"confirmed\": false\n        }\n    }\n    debug(device, \"txTime\", `${device.identity.deviceName} (${device.controller.protocol}) : TX time = ${Date.now() - device.transmitTime} ms`);\n    return downlinkJson;\n}\n//////////////////////////////////////////////////////////////////////////\n// Chipstack Network Server \n/////////////////////////////////////////////////////////////////////////\n// 1. Flush the downlink Queue\n\nif (device.lorawan.networkServer == \"chirpstack\") {\n    if (device.lorawan.flushDownlinkQueue == true) {\n\n        //We include flow value from libraries\n        var grpc = flow.get('grpc');\n        var device_grpc = flow.get('device_grpc');\n        var device_pb = flow.get('device_pb');\n\n        // This must point to the ChirpStack API interface.\n        const server = \"chirpstack.univ-lorawan.fr:9090\";\n        // The DevEUI for which we want to enqueue the downlink.\n        const devEui = device.identity.devEUI;\n        \n        // The API token (can be obtained through the ChirpStack web-interface).\n        const apiToken = device.lorawan.chirpstack.grpcApikey;\n\n        // Create the client for the DeviceService.\n        const deviceService = new device_grpc.DeviceServiceClient(\n            server,\n            grpc.credentials.createInsecure(),\n        );\n\n        // Create the Metadata object.\n        const metadata = new grpc.Metadata();\n        metadata.set(\"authorization\", \"Bearer \" + apiToken);\n\n        //Flush downlink queue request\n        const flushReq = new device_pb.FlushDeviceQueueRequest();\n        flushReq.setDevEui(devEui);\n\n        //Send the request\n        deviceService.flushQueue(flushReq, metadata, (err, resp) => {\n            if (err !== null) {\n                //node.error(`Can't flush ChirpStack downlink queue :  ${err}`);\n            }\n        });\n    }\n\n    // 2. Prepare downlink JSON\n    downlinkJson = {\n        \"topic\": device.mqtt.topicDownlink,\n        \"payload\": {\n            \"devEui\": device.identity.devEUI,\n            \"confirmed\": false,\n            \"fPort\": device.lorawan.downlinkPort,\n            \"object\": msg.payload\n        }\n    }\n    debug(device, \"txTime\", `${device.identity.deviceName} (${device.controller.protocol}) : TX time = ${Date.now() - device.transmitTime} ms`); \n    return downlinkJson;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n// Actility Network Server \n/////////////////////////////////////////////////////////////////////////\nif (device.lorawan.networkServer == \"actility\") {\n    downlinkJson = {\n        \"topic\": device.mqtt.topicDownlink,\n        \"payload\": {\n            \"DevEUI_downlink\": {\n                \"DevEUI\": device.identity.devEUI,\n                \"FPort\": device.lorawan.downlinkPort,\n                \"payload\": msg.payload,\n                \"FlushDownlinkQueue\": String(+device.lorawan.flushDownlinkQueue),\n                \"DriverCfg\": {\n                    \"app\": {\n                        \"pId\": device.lorawan.actility.driver.pId,\n                        \"mId\": device.lorawan.actility.driver.mId,\n                        \"ver\": device.lorawan.actility.driver.ver\n                    }\n                }\n            }\n        }\n    }\n    debug(device, \"txTime\", `${device.identity.deviceName} (${device.controller.protocol}) : TX time = ${Date.now() - device.transmitTime} ms`);\n    return downlinkJson;\n}\n\n\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "GrpcJs",
                "module": "@grpc/grpc-js"
            }
        ],
        "x": 270,
        "y": 500,
        "wires": [
            [
                "23302f7da6ac348f"
            ]
        ],
        "icon": "node-red/bridge-dash.svg"
    },
    {
        "id": "02228be706349069",
        "type": "function",
        "z": "5cc5759c4e59a5b9",
        "g": "87884948644d31d9",
        "name": "Update previousValues",
        "func": "let previousValues = flow.get(\"g_previousValues\");\nlet deviceName = msg.device.identity.deviceName;\nlet previousBacnetObject = previousValues[deviceName].bacnet.objects;\n\nfor (let object in msg.payload) {\n    previousBacnetObject[object].value =  msg.payload[object] ;\n}\n\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 460,
        "wires": [
            []
        ],
        "icon": "font-awesome/fa-history"
    },
    {
        "id": "89faa192f420e27a",
        "type": "function",
        "z": "5cc5759c4e59a5b9",
        "g": "d39199becfb613a9",
        "name": "WRITE uplink objects",
        "func": "let client = new nodeBacnet();\nlet device = msg.device;\nlet debug = flow.get(\"g_debug\");\nlet temp;\n\n// If the device controller protocol is not \"bacnet\" there is no need to be here \nif(device.controller.protocol != \"bacnet\") return null;\n\nlet bacnetObject = device.bacnet.objects;\n\nfor (let object in bacnetObject) {\n  if (bacnetObject[object].dataDirection === \"uplink\") {\n    //  Read of the uplink bacnet objects\n    client.writeProperty(device.controller.ipAddress, {type: bacnetObject[object].objectType, instance: bacnetObject[object].instanceNum}, 85, [{type: ((bacnetObject[object].objectType == 2) ? 4 : 0), value: bacnetObject[object].value}], (err, value) => {\n      if(err){\n          msg.payload = err;\n          node.status({fill:\"red\",shape:\"dot\",text:\"BACnet \"+ err});\n          node.error(\"Error writing bacnet objects\", {\n            errorType: \"nativeBACnet\",\n            error: err,\n            \n          });\n          return null;\n        } else {\n          msg.payload = value;\n          debug(device, \"up\",`${device.identity.deviceName} (${device.controller.protocol}) : Write Uplink Objects`)\n          node.status({fill:\"green\",shape:\"dot\",text:\"Native BACnet\"});\n        }\n    });\n\n  }\n}\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "nodeBacnet",
                "module": "node-bacnet"
            }
        ],
        "x": 866,
        "y": 260,
        "wires": [
            [
                "82c973a25a9fff5f"
            ]
        ]
    },
    {
        "id": "82c973a25a9fff5f",
        "type": "function",
        "z": "5cc5759c4e59a5b9",
        "g": "cf0f4185b7b366fc",
        "name": "READ downlink objects",
        "func": "let client = new nodeBacnet();\nlet device = msg.device;\nlet bacnetObject = device.bacnet.objects;\nlet debug = flow.get(\"g_debug\");\nlet requestArray = [];\n\nif (device.controller.protocol != \"bacnet\") return null;\n\n// Build the request array\nfor (let object in bacnetObject) {\n  if (bacnetObject[object].dataDirection === \"downlink\") {\n    let temp = JSON.parse('{\"objectId\": { \"type\":' + bacnetObject[object].objectType + ', \"instance\":' + bacnetObject[object].instanceNum + '},\"properties\": [ {\"id\": 85} ] }');\n    requestArray.push(temp);\n  }\n}\n\n// Use a Promise to manage the asynchronous function\nreturn new Promise((resolve, reject) => {\n  client.readPropertyMultiple(device.controller.ipAddress, requestArray, (err, value) => {\n    if (err) {\n      node.error(err);\n      node.status({ fill: \"red\", shape: \"dot\", text: \"BACnet \" + err });\n      reject(err); // reject the promise in case of error\n    } else if (value) {\n      msg.payload = value;\n      debug(device, \"down\", `${device.identity.deviceName} (${device.controller.protocol}) : Read downlink Objects`);\n      node.status({ fill: \"green\", shape: \"dot\", text: \"Native BACnet\" });\n      resolve(msg); // resolve the promise with the node message\n    }\n  });\n}).then((msg) => {\n  // once the promise has been resolved\n  let values = msg.payload.values || [];\n  // store the values in the device objects value property\n  for (let i = 0; i < values.length; i++) {\n    Object.values(bacnetObject).forEach(obj => {\n      if (values[i].objectId.type == obj.objectType && values[i].objectId.instance == obj.instanceNum) {\n        obj.value = values[i].values[0].value[0].value;\n      }\n    });\n  }\n  return {\n    \"device\":device\n  };\n}).catch((err) => {\n  node.status({ fill: \"red\", shape: \"dot\", text: err });\n  node.error(\"Error reading bacnet objects\", {\n    errorType: \"nativeBACnet\",\n    error: err,\n\n  });\n  return null;\n});",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "nodeBacnet",
                "module": "node-bacnet"
            }
        ],
        "x": 1270,
        "y": 260,
        "wires": [
            [
                "37625d0e5293d94f"
            ]
        ]
    },
    {
        "id": "940fec9018446d96",
        "type": "inject",
        "z": "5cc5759c4e59a5b9",
        "g": "ad4aaedc86729471",
        "name": "5 seconds timer",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "5",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "true",
        "payloadType": "bool",
        "x": 85,
        "y": 700,
        "wires": [
            [
                "9b85152b47c16eb0"
            ]
        ],
        "icon": "node-red/timer.svg",
        "l": false
    },
    {
        "id": "9b85152b47c16eb0",
        "type": "function",
        "z": "5cc5759c4e59a5b9",
        "g": "ad4aaedc86729471",
        "name": "READ Downlink Objects",
        "func": "let devices = RED.util.cloneMessage(flow.get(\"g_previousValues\"));\nlet client = new nodeBacnet()\nconst debug = flow.get('g_debug');\n\n// No action will be taken if the application doesn't know any devices\nif (devices === undefined){\n    return null ;\n}\n\nfor (let device in devices) {\n    if (devices[device].lorawan[\"class\"]?.toLowerCase() === \"c\"){  \n        let bacnetObjects = devices[device].bacnet.objects;\n        \n\n        switch (devices[device].controller.protocol) {\n            case \"bacnet\":\n                let requestArray = [];\n                let downlinkobject = {};\n                downlinkobject[\"result\"] = [];\n                // Build the request array\n                for (let object in bacnetObjects) {\n                  if (bacnetObjects[object].dataDirection === \"downlink\" && (bacnetObjects[object].downlinkStrategie === \"onChangeOfValue\" || bacnetObjects[object].downlinkStrategie === \"onChangeOfValueWithinRange\")) {\n                    let temp = JSON.parse('{\"objectId\": { \"type\":' + bacnetObjects[object].objectType + ', \"instance\":' + bacnetObjects[object].instanceNum + '},\"properties\": [ {\"id\": 85} ] }');\n                    requestArray.push(temp);\n                  }\n                }\n\n                // Use a Promise to manage the asynchronous function\n                return new Promise((resolve, reject) => {\n                  client.readPropertyMultiple('192.168.1.108', requestArray, (err, value) => {\n                    if (err) {\n                      node.error(err);\n                      node.status({ fill: \"red\", shape: \"dot\", text: \"BACnet \" + err });\n                      reject(err); // reject the promise in case of error\n                    } else if (value) {\n                      msg.payload = value;\n                      node.status({ fill: \"green\", shape: \"ring\", text: \"Native BACnet\" });\n                      resolve(msg); // resolve the promise with the node message\n                    }\n                  });\n                }).then((msg) => {\n                  // once the promise has been resolved\n                  let values = msg.payload.values || [];\n                  // store the values in the device objects value property\n                  for (let i = 0; i < values.length; i++) {\n                    downlinkobject.result[i][\"objectType\"] =  values[i].objectId.type;\n                    downlinkobject.result[i][\"instanceNum\"] =  values[i].objectId.instance;\n                    downlinkobject.result[i][\"value\"] =  values[i].values[0].value[0].value;\n\n                  }\n                  msg = {\n                    \"request\":{\n                                \"downlinkobject\" : downlinkobject,\n                                \"deviceName\": device,\n                                \"device\" : devices[device]\n                            }\n                  };\n                node.send(msg);\n                }).catch((err) => {\n                  node.status({ fill: \"red\", shape: \"dot\", text: err });\n                  node.error(\"Error reading bacnet objects\", {\n                    errorType: \"nativeBACnet\",\n                    error: err,\n                \n                  });\n                  return null;\n                });\n                break;\n            case \"restAPIBacnet\":\n                node.status({ fill: \"green\", shape: \"ring\", text: \"RestAPI BACnet\" });\n                switch (devices[device].controller.model){ \n                    ///////////////////////////////////////////////////////////\n                    ////// Distech Controls Eclypse APEX\n                    ////// https://www.postman.com/distech/distech-ecy-v2-public/request/rsns661/read-property-multiple\n                    ///////////////////////////////////////////////////////////\n                    case \"distechControlsV2\":\n                        /********** HTTP Request Read Multiple Properties \n                        {\n                            \"method\": \"POST\",\n                            \"url\": url,\n                            \"headers\": {Authorization: flow.get('$parent.g_httpAuthentication'),\n                                          ContentType: \"application/json\"}\n                            \"payload\": {\n                                \"encode\": \"text\",\n                                \"property-references\": [\n                                    {\n                                      \"type\": \"analogValue\",\n                                      \"instance\": 1,\n                                      \"property\": \"presentValue\"\n                                    },\n                                    {\n                                      \"type\": \"analogValue\",\n                                      \"instance\": 4,\n                                      \"property\": \"presentValue\"\n                                    },\n                                    ...\n                                ]\n                            },\n                            \"requestTimeout\" : xxx (ms)\n                        }\n                        */\n        \n                        let property_references = [];\n        \n                       // debug(devices[device], \"down\", `${device} (RestAPI) : Read Downlink Objects for class C`);\n                        for (let object in bacnetObjects) {\n                            // Only the object with the \"onChangeOfValue\" or the \"onChangeOfValueWithinRange\" downlink strategie are fetched\n                          if (bacnetObjects[object].dataDirection === \"downlink\" && (bacnetObjects[object].downlinkStrategie === \"onChangeOfValue\" || bacnetObjects[object].downlinkStrategie === \"onChangeOfValueWithinRange\")) {\n                                let temp = '{ \"type\": \"' + bacnetObjects[object].objectType + '\", \"instance\": ' + bacnetObjects[object].instanceNum + ', \"property\": \"presentValue\" }';\n                                property_references.push(JSON.parse(temp));\n                            }\n                        }\n        \n        \n                        // Return HTTP Request\n                        node.send({\n                            \"request\":{\n                                \"method\": \"POST\",\n                                \"url\": \"https://\" + devices[device].controller.ipAddress + \"/api/rest/v2/services/bacnet/local/objects/read-property-multiple\",\n                                \"headers\": {\n                                    Authorization: devices[device].controller.httpAuthentication,\n                                    ContentType: \"application/json\"\n                                },\n                                \"payload\": {\n                                    \"encode\": \"text\",\n                                    \"property-references\": property_references\n                                },\n                                \"requestTimeout\": flow.get('g_httpRequestTimeOut'),\n                                \"deviceName\": device,\n                                \"device\" : devices[device]\n                            }\n                        });\n        \n        \n                    ///////////////////////////////////////////////////////////\n                    ////// XXXXX Controller\n                    ////// URL to the API documentation\n                    ///////////////////////////////////////////////////////////\n                    case \"anotherController\":\n\n                        break;\n                    default:\n\n                }\n                break;\n            default:\n                        \n        }\n\n\n    }\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "nodeBacnet",
                "module": "node-bacnet"
            }
        ],
        "x": 244.28571428571422,
        "y": 700,
        "wires": [
            [
                "54f5534c655aa398"
            ]
        ]
    },
    {
        "id": "d00282e8150bf0bd",
        "type": "http request",
        "z": "5cc5759c4e59a5b9",
        "g": "ad4aaedc86729471",
        "name": "HTTP REQUEST",
        "method": "use",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "38c4db63982e52db",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 821.4285714285716,
        "y": 660,
        "wires": [
            [
                "cdbf6221de3e6198"
            ]
        ]
    },
    {
        "id": "da83a8fbb75177d9",
        "type": "function",
        "z": "5cc5759c4e59a5b9",
        "g": "ad4aaedc86729471",
        "name": "prepare the downlink",
        "func": "/////////////////////////////////////////////////////////////////////\n/////////////////  Store Downlink Objects              //////////////\n/////////////////////////////////////////////////////////////////////\n/* This function stores the downlink data from the controller */\nconst previousValues = RED.util.cloneMessage(flow.get(\"g_previousValues\"));\nconst deviceName = msg.deviceName;\nconst device = previousValues[deviceName];\nif (device.lorawan.hasOwnProperty(\"defaultValuesForDownlink\")) {var staticDownlinkObjects = device.lorawan.defaultValuesForDownlink}\nlet bacnetObjects = RED.util.cloneMessage(previousValues[deviceName].bacnet.objects);\nconst debug = flow.get('g_debug');\nlet downlinkLowPriorityObject = 0;\nlet payload={};\n\nfunction downlinkPayloadCreation(downlinkObjectToSend) {\n    //Creation of the downlink payload\n    for (let obj in bacnetObjects) {\n        if (bacnetObjects[obj].dataDirection === \"downlink\" && bacnetObjects[obj].downlinkPort == bacnetObjects[downlinkObjectToSend].downlinkPort) {\n            let temp = \"{ \\\"\" + obj + \"\\\" : \" + JSON.stringify(bacnetObjects[obj].value) + \" }\";\n            payload = { ...payload, ...JSON.parse(temp) }\n        }\n    }\n    // Chek if there are other values to add to the payload\n    if (device.lorawan.hasOwnProperty(\"defaultValuesForDownlink\")) {\n        if (device.lorawan.defaultValuesForDownlink.hasOwnProperty(\"fPort_\" + bacnetObjects[downlinkObjectToSend].downlinkPort)) {\n            for (let obj in staticDownlinkObjects[\"fPort_\" + bacnetObjects[downlinkObjectToSend].downlinkPort]) {\n                let temp = \"{ \\\"\" + obj + \"\\\" : \" + JSON.stringify(staticDownlinkObjects[\"fPort_\" + bacnetObjects[downlinkObjectToSend].downlinkPort][obj]) + \" }\";\n                payload = { ...payload, ...JSON.parse(temp) }\n\n            }\n        }\n    }\n    msg = {\n        \"payload\": payload,\n        \"device\": device\n    }\n    msg.device.lorawan.downlinkPort = bacnetObjects[downlinkObjectToSend].downlinkPort\n\n}\n\nswitch (previousValues[deviceName].controller.model) {\n    case \"distechControlsV2\":\n        let donwlinkObjects = msg.payload;\n\n        for (let i = 0; i < donwlinkObjects.results.length; i++) {\n            Object.values(bacnetObjects).forEach(obj => {\n                if (donwlinkObjects.results[i].type == obj.objectType && donwlinkObjects.results[i].instance == obj.instanceNum) {\n                    if (obj.objectType == \"analogValue\") obj.value = Number(donwlinkObjects.results[i].value);\n                    if (obj.objectType == \"binaryValue\") obj.value = donwlinkObjects.results[i].value;\n                }\n            });\n        }\n    ///////////////////////////////////////////////////////////\n    ////// XXXXX Controller\n    ////// URL to the API documentation\n    ///////////////////////////////////////////////////////////\n    case \"anotherController\":\n\n}\n///////////////////////////////////////////////////////////\n///////  This part check if a downlink is needed  /////////\n///////////////////////////////////////////////////////////\nfor (let object in bacnetObjects) {\n  if (bacnetObjects[object].dataDirection === \"downlink\" && (bacnetObjects[object].downlinkStrategie === \"onChangeOfThisValue\" || bacnetObjects[object].downlinkStrategie === \"onChangeOfThisValueWithinRange\")) {\n\n      switch (bacnetObjects[object].downlinkPortPriority) {\n          case \"high\":\n            switch (bacnetObjects[object].downlinkStrategie) {\n                case \"onChangeOfThisValue\":\n                    if (bacnetObjects[object].value != previousValues[deviceName].bacnet.objects[object].value) {\n                    node.status({ fill: \"yellow\", shape: \"dot\", text: \"Downlink\" });\n                    debug(device, \"down\", `${deviceName} (${previousValues[deviceName].controller.protocol}) : Downlink scheduled : Previous value ${previousValues[deviceName].bacnet.objects[object].value}  != ${object} ${bacnetObjects[object].value}`);\n                    //Creation of the dowlink payload\n                    downlinkPayloadCreation(object)\n                    return msg\n                    }     \n                    break;\n                case \"onChangeOfThisValueWithinRange\":\n                    if (bacnetObjects[object].value != previousValues[deviceName].bacnet.objects[object].value && bacnetObjects[object].value <= bacnetObjects[object].range[1] && bacnetObjects[object].value >= bacnetObjects[object].range[0]) {\n                    node.status({ fill: \"yellow\", shape: \"dot\", text: \"Downlink\" });\n                    debug(device, \"down\", `${deviceName} (${previousValues[deviceName].controller.protocol}) : Downlink scheduled : Previous value ${previousValues[deviceName].bacnet.objects[object].value}  != ${object} ${bacnetObjects[object].value}`);\n                    //Creation of the dowlink payload\n                    downlinkPayloadCreation(object)\n                    return msg\n                    }    \n                    break;\n                default:\n                    \n            }\n              \n              break;\n          case \"low\":\n              //In case of low priority downlink the object name is kept till the end of the for loop \n              // to be sure that there is not any high priority downlink to send \n              switch (bacnetObjects[object].downlinkStrategie) {\n                case \"onChangeOfThisValue\":\n                    if (bacnetObjects[object].value != previousValues[deviceName].bacnet.objects[object].value) {\n                        downlinkLowPriorityObject = object;\n                    }\n                    break;\n                case \"onChangeOfThisValueWithinRange\":\n                    if (bacnetObjects[object].value != previousValues[deviceName].bacnet.objects[object].value && bacnetObjects[object].value <= bacnetObjects[object].range[1] && bacnetObjects[object].value >= bacnetObjects[object].range[0]) {\n                        downlinkLowPriorityObject = object;\n                    }\n                    break;\n                default:\n                    \n              }\n              break;\n          default:\n\n      }\n  }\n}\nif (downlinkLowPriorityObject != 0) {\n    node.status({ fill: \"yellow\", shape: \"dot\", text: \"Downlink\" });\n    debug(device, \"down\", `${deviceName} (${previousValues[deviceName].controller.protocol}) : Downlink scheduled : Previous value ${previousValues[deviceName].bacnet.objects[downlinkLowPriorityObject].value}  != ${downlinkLowPriorityObject} ${bacnetObjects[downlinkLowPriorityObject].value}`);     \n  \n    //Creation of the dowlink payload\n    downlinkPayloadCreation(downlinkLowPriorityObject)\n    return msg            \n}else{\n\n  node.status({fill: \"green\", shape: \"dot\" ,text: \"No downlink\"});\n  return null;\n}\n\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1045.7142857142858,
        "y": 700,
        "wires": [
            [
                "f9accd901cfb1adf"
            ]
        ]
    },
    {
        "id": "79e3086f522954f1",
        "type": "queue",
        "z": "5cc5759c4e59a5b9",
        "g": "ad4aaedc86729471",
        "name": "",
        "input": "request",
        "inputType": "msg",
        "addFields": "\"\"",
        "addFieldsType": "json",
        "pourType": "initial",
        "pourTypeType": "pourType",
        "pourTime": "1",
        "pourTimeType": "num",
        "pourAmount": "1",
        "pourAmountType": "num",
        "maxUseMemory": "",
        "x": 472.85714285714283,
        "y": 700,
        "wires": [
            [
                "f8bce9cacf1c7e16"
            ]
        ]
    },
    {
        "id": "6d24d636d121f3ca",
        "type": "link out",
        "z": "5cc5759c4e59a5b9",
        "g": "cf0f4185b7b366fc",
        "name": "MQTT send downlink",
        "mode": "link",
        "links": [
            "39818c1b22452bed"
        ],
        "x": 1920,
        "y": 180,
        "wires": [],
        "l": true
    },
    {
        "id": "39818c1b22452bed",
        "type": "link in",
        "z": "5cc5759c4e59a5b9",
        "g": "87884948644d31d9",
        "name": "MQTT downlink In",
        "links": [
            "6d24d636d121f3ca",
            "f9accd901cfb1adf"
        ],
        "x": 65,
        "y": 480,
        "wires": [
            [
                "95b76c27610df7c7"
            ]
        ]
    },
    {
        "id": "f9accd901cfb1adf",
        "type": "link out",
        "z": "5cc5759c4e59a5b9",
        "g": "ad4aaedc86729471",
        "name": "MQTT send downlink",
        "mode": "link",
        "links": [
            "39818c1b22452bed"
        ],
        "x": 1280,
        "y": 700,
        "wires": [],
        "l": true
    },
    {
        "id": "f8bce9cacf1c7e16",
        "type": "function",
        "z": "5cc5759c4e59a5b9",
        "g": "ad4aaedc86729471",
        "name": "way selector",
        "func": "switch (msg.request[0].device.controller.protocol) {\n    case \"bacnet\":\n        // Rebuild the message correctly\n        msg = {\n            \"downlinkobject\" : msg.request[0].downlinkobject,\n            \"deviceName\":msg.request[0].deviceName,\n            \"device\": msg.request[0].device\n            }\n        return [null,msg];\n        break;\n    case \"restAPIBacnet\":\n        // Rebuild the message correctly\n        msg = {\n            \"method\":msg.request[0].method,\n            \"url\":msg.request[0].url,\n            \"headers\":msg.request[0].headers,\n            \"payload\":msg.request[0].payload,\n            \"requestTimeout\":msg.request[0].requestTimeout,\n            \"deviceName\":msg.request[0].deviceName,\n            \"device\": msg.request[0].device\n            }\n        return [msg,null];\n        break;\n    default:\n    node.status({fill:\"red\",shape:\"dot\",text:\"error unknown protocol\"});\n        \n}",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 627.1428571428572,
        "y": 700,
        "wires": [
            [
                "d00282e8150bf0bd"
            ],
            [
                "cdbf6221de3e6198"
            ]
        ],
        "outputLabels": [
            "RrstAPIBacnet",
            "bacnet"
        ],
        "icon": "node-red/switch.svg"
    },
    {
        "id": "42fdce6627e1c84a",
        "type": "debug",
        "z": "5cc5759c4e59a5b9",
        "g": "61078575c808c2ab",
        "name": "debug MQTT uplink",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 240,
        "wires": []
    },
    {
        "id": "91a6d3be5cc29a58",
        "type": "catch",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "Error handler",
        "scope": null,
        "uncaught": false,
        "x": 120,
        "y": 1080,
        "wires": [
            [
                "2672c46a814535c9",
                "6d467d750a6fb9b9"
            ]
        ]
    },
    {
        "id": "2672c46a814535c9",
        "type": "switch",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "error type selector",
        "property": "errorType",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "deviceListLoRaWANConfiguration",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "deviceListBACnetObjectConfiguration",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "deviceListBACnetObjectConfigurationMissingProperty",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "deviceListControllerConfiguration",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "deviceListBACnetConfiguration",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "deviceListOverlap",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "deviceName",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "nativeBACnet",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "deviceListOverlapManual",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 320.66666666666663,
        "y": 1080,
        "wires": [
            [
                "cd6eb225595d17b3"
            ],
            [
                "4c4bc0ee5a41d05f"
            ],
            [
                "51649d38f610b411"
            ],
            [
                "d5079b16928ea8f4"
            ],
            [
                "d54c86c0295989c9"
            ],
            [
                "de44e5b3194f58ab"
            ],
            [
                "300303076a0c87d2"
            ],
            [
                "73172af1e339dd33"
            ],
            [
                "44f453239caa5eac"
            ]
        ],
        "outputLabels": [
            "LoRaWAN Config error",
            "BACnetObject Config  error",
            "BACnetObject Config missing property error",
            "Controller Config  error",
            "BACnet Config  error",
            "Overlap Config  error",
            "device name error",
            "native BACnet error",
            null
        ]
    },
    {
        "id": "f53279ccc6e6c1b4",
        "type": "debug",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "deviceList LoRaWAN Configuration Error",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 830,
        "y": 880,
        "wires": []
    },
    {
        "id": "cd6eb225595d17b3",
        "type": "template",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "<===============================================================================>\n<=================================   ERROR   ===================================>\n<===============================================================================>\n{{error.message}}\n\nPlease only use the supported network server: 'chirpstack', 'tts' or 'Actility'.\n\nFor more information see the documentation on Github.\nhttps://github.com/SylvainMontagny/LoRaBAC\n\nDevice concerned: {{device}}\nproperty concerned: lorawan.{{property}}\n<===============================================================================>",
        "output": "str",
        "x": 494.33333333333326,
        "y": 880,
        "wires": [
            [
                "f53279ccc6e6c1b4"
            ]
        ],
        "icon": "node-red/comment.svg",
        "l": false
    },
    {
        "id": "51649d38f610b411",
        "type": "template",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "<===============================================================================>\n<=================================   ERROR   ===================================>\n<===============================================================================>\n{{error.message}}\n\nPlease be sure to have all the necessary property for each Bacnet objects:\n\n----------------------------------------------------\n| Property              | Uplink         | Downlink |\n----------------------------------------------------\n| lorawanPayloadName    | required       | required |\n| objectType            | required       | required |\n| assignementMode       | required       | required |\n| instanceNum           | required       | required |\n| dataDirection         | required       | required |\n| value                 | required       | required |\n| downlinkPort          | not required   | required |\n| downlinkPortPriority  | not required   | required |\n| downlinkStrategie     | not required   | required |\n| uplinkToCompareWith   | not required   | required |\n----------------------------------------------------\n\nFor more information see the documentation on Github.\nhttps://github.com/SylvainMontagny/LoRaBAC\n\nDevice concerned: {{device}}\nMissing property: {{property}}\n<===============================================================================>",
        "output": "str",
        "x": 494.33333333333326,
        "y": 1040,
        "wires": [
            [
                "6d3a7829e3e402e9"
            ]
        ],
        "icon": "node-red/comment.svg",
        "l": false
    },
    {
        "id": "d5079b16928ea8f4",
        "type": "template",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "<===============================================================================>\n<=================================   ERROR   ===================================>\n<===============================================================================>\n{{error.message}}\n\nPlease only use the supported protocols: 'restAPIbacnet' or 'bacnet'.\n\nFor more information see the documentation on Github.\nhttps://github.com/SylvainMontagny/LoRaBAC\n\nDevice concerned: {{device}}\nProperty concerned: controller.{{property}}\nActual value: {{value}}\n<===============================================================================>",
        "output": "str",
        "x": 494.33333333333326,
        "y": 1080,
        "wires": [
            [
                "05c8d8e553e7b93c"
            ]
        ],
        "icon": "node-red/comment.svg",
        "l": false
    },
    {
        "id": "d54c86c0295989c9",
        "type": "template",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "<===============================================================================>\n<=================================   ERROR   ===================================>\n<===============================================================================>\n{{error.message}}\n\nPlease do not use more Bacnet object than the instance range number or increase it.\n\nFor more information see the documentation on Github.\nhttps://github.com/SylvainMontagny/LoRaBAC\n\nDevice concerned: {{device}}\nProperty concerned: bacnet.{{property}}\nActual value: {{value}}\n<===============================================================================>",
        "output": "str",
        "x": 494.33333333333326,
        "y": 1120,
        "wires": [
            [
                "ba5c69dff97964d6"
            ]
        ],
        "icon": "node-red/comment.svg",
        "l": false
    },
    {
        "id": "de44e5b3194f58ab",
        "type": "template",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "<===============================================================================>\n<=================================   ERROR   ===================================>\n<===============================================================================>\n{{error.message}}\n\nPlease be sure to set the offset, maxDeviceNum and instance range correctly.\n\nFor more information see the documentation on Github.\nhttps://github.com/SylvainMontagny/LoRaBAC\n\nFirst device concerned: {{device1}}\nSecond device concerned: {{device2}}\n<===============================================================================>",
        "output": "str",
        "x": 494.33333333333326,
        "y": 1160,
        "wires": [
            [
                "7f740ef6194bf32a"
            ]
        ],
        "icon": "node-red/comment.svg",
        "l": false
    },
    {
        "id": "6d3a7829e3e402e9",
        "type": "debug",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "deviceList BACnet Objects Configuration Missing Property Error",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 900,
        "y": 1040,
        "wires": []
    },
    {
        "id": "05c8d8e553e7b93c",
        "type": "debug",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "deviceList Controller Configuration Error",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 830,
        "y": 1080,
        "wires": []
    },
    {
        "id": "ba5c69dff97964d6",
        "type": "debug",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "deviceList BACnet Configuration Error",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 820,
        "y": 1120,
        "wires": []
    },
    {
        "id": "7f740ef6194bf32a",
        "type": "debug",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "deviceList Overlap Configuration Error",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 820,
        "y": 1160,
        "wires": []
    },
    {
        "id": "f65871545cbfa045",
        "type": "template",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "<===============================================================================>\n<=================================   ERROR   ===================================>\n<===============================================================================>\n{{error.message}}\n\nPlease be sure that the range of the \"onChangeOfValueWithinRange\" downlink strategie is a two value array:\n\n\"range\":[a,b] \nwith a < b\n\nFor more information see the documentation on Github.\nhttps://github.com/SylvainMontagny/LoRaBAC\n\nDevice concerned: **{{device}}**\nObject concerned: **{{object}}**\nProperty concerned: **{{property}}**\nActual value: **{{value}}**\n<===============================================================================>",
        "output": "str",
        "x": 565,
        "y": 900,
        "wires": [
            [
                "395810ba2850e941"
            ]
        ],
        "icon": "node-red/comment.svg",
        "l": false
    },
    {
        "id": "300303076a0c87d2",
        "type": "template",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "<===============================================================================>\n<=================================   ERROR   ===================================>\n<===============================================================================>\n{{error.message}}\n\nPlease be sure to set the device name correctly on the network server.\n\nFor more information see the documentation on Github.\nhttps://github.com/SylvainMontagny/LoRaBAC\n\nActual name of the device: {{value}}\n<===============================================================================>",
        "output": "str",
        "x": 494.33333333333326,
        "y": 1200,
        "wires": [
            [
                "b320b88a63df2793"
            ]
        ],
        "icon": "node-red/comment.svg",
        "l": false
    },
    {
        "id": "b320b88a63df2793",
        "type": "debug",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "deviceName Error",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 1200,
        "wires": []
    },
    {
        "id": "73172af1e339dd33",
        "type": "template",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "<===============================================================================>\n<=================================   ERROR   ===================================>\n<===============================================================================>\n{{error.message}}\n\nPlease be sure that the bacnet objects exist on your controller.\n\nFor more information see the documentation on Github.\nhttps://github.com/SylvainMontagny/LoRaBAC\n\n{{_error}}\n<===============================================================================>",
        "output": "str",
        "x": 494.33333333333326,
        "y": 1240,
        "wires": [
            [
                "2f3f132843034187"
            ]
        ],
        "icon": "node-red/comment.svg",
        "l": false
    },
    {
        "id": "2f3f132843034187",
        "type": "debug",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "nativeBAcnet Error",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 1240,
        "wires": []
    },
    {
        "id": "6d467d750a6fb9b9",
        "type": "debug",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "debug error handler",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 320.66666666666663,
        "y": 980,
        "wires": []
    },
    {
        "id": "c17ded1dd0e7ad6b",
        "type": "debug",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "deviceList BACnet Objects Configuration Error",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 840,
        "y": 960,
        "wires": []
    },
    {
        "id": "4c4bc0ee5a41d05f",
        "type": "switch",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "",
        "property": "property",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "range",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "instanceNum",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "assignementMode",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "downlinkStrategie",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 4,
        "x": 494.33333333333326,
        "y": 960,
        "wires": [
            [
                "f65871545cbfa045"
            ],
            [
                "83c3210d6af69f2a"
            ],
            [
                "a27cbfe63e5a81c3"
            ],
            [
                "cbfaa875d5a7e005"
            ]
        ],
        "outputLabels": [
            "Range error",
            "InstanceNum error",
            "assignementMode error",
            null
        ],
        "l": false
    },
    {
        "id": "83c3210d6af69f2a",
        "type": "template",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "<===============================================================================>\n<=================================   ERROR   ===================================>\n<===============================================================================>\n{{error.message}}\n\nPlease be sure that the instanceNum of your BACnet objects is not superior or equal to the instance range.\n\nFor more information see the documentation on Github.\nhttps://github.com/SylvainMontagny/LoRaBAC\n\nDevice concerned: **{{device}}**\nObject concerned: **{{object}}**\nProperty concerned: **{{property}}**\nActual value: **{{value}}**\n<===============================================================================>",
        "output": "str",
        "x": 565,
        "y": 940,
        "wires": [
            [
                "395810ba2850e941"
            ]
        ],
        "icon": "node-red/comment.svg",
        "l": false
    },
    {
        "id": "7a200378e7bc7755",
        "type": "complete",
        "z": "5cc5759c4e59a5b9",
        "g": "ad4aaedc86729471",
        "name": "Http request complete handler",
        "scope": [
            "d00282e8150bf0bd"
        ],
        "uncaught": false,
        "x": 190,
        "y": 760,
        "wires": [
            [
                "c0d116b23c19852f"
            ]
        ],
        "icon": "font-awesome/fa-check"
    },
    {
        "id": "c0d116b23c19852f",
        "type": "change",
        "z": "5cc5759c4e59a5b9",
        "g": "ad4aaedc86729471",
        "name": "dequeue",
        "rules": [
            {
                "t": "set",
                "p": "dequeue",
                "pt": "msg",
                "to": "true",
                "tot": "bool"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 390,
        "y": 760,
        "wires": [
            [
                "54f5534c655aa398"
            ]
        ]
    },
    {
        "id": "63bb78783744a097",
        "type": "subflow:4d0f0c0771ab4500",
        "z": "5cc5759c4e59a5b9",
        "g": "cf0f4185b7b366fc",
        "name": "Rest API Read downlink/Write uplink",
        "env": [
            {
                "name": "dataDirection",
                "value": "downlink",
                "type": "str"
            }
        ],
        "x": 1290,
        "y": 120,
        "wires": [
            [
                "3770a2d7b36f50bb"
            ]
        ]
    },
    {
        "id": "d66b2fc77c914ef1",
        "type": "debug",
        "z": "5cc5759c4e59a5b9",
        "g": "cf0f4185b7b366fc",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1600,
        "y": 120,
        "wires": []
    },
    {
        "id": "44f453239caa5eac",
        "type": "template",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "<===============================================================================>\n<=================================   ERROR   ===================================>\n<===============================================================================>\n{{error.message}}\n\nPlease be sure to set the offset, maxDeviceNum and instance range correctly to not overlap mannualy set objects.\n\nFor more information see the documentation on Github.\nhttps://github.com/SylvainMontagny/LoRaBAC\n\nDevice concerned: {{device}}\nInstance Number concerned: {{instanceNum}}\n<===============================================================================>",
        "output": "str",
        "x": 494.33333333333326,
        "y": 1280,
        "wires": [
            [
                "4f919cc79b35d6f1"
            ]
        ],
        "icon": "node-red/comment.svg",
        "l": false
    },
    {
        "id": "4f919cc79b35d6f1",
        "type": "debug",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "deviceList Overlap Configuration Error",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 820,
        "y": 1280,
        "wires": []
    },
    {
        "id": "a27cbfe63e5a81c3",
        "type": "template",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "<===============================================================================>\n<=================================   ERROR   ===================================>\n<===============================================================================>\n{{error.message}}\n\nPlease be sure that the assignement mode of each object of a device type are the same.\n\nFor more information see the documentation on Github.\nhttps://github.com/SylvainMontagny/LoRaBAC\n\nDevice concerned: **{{device}}**\nObject concerned: **{{object}}**\nProperty concerned: **{{property}}**\nActual value: **{{value}}**\n<===============================================================================>",
        "output": "str",
        "x": 565,
        "y": 980,
        "wires": [
            [
                "395810ba2850e941"
            ]
        ],
        "icon": "node-red/comment.svg",
        "l": false
    },
    {
        "id": "e852d3c25ec22203",
        "type": "link in",
        "z": "5cc5759c4e59a5b9",
        "g": "61078575c808c2ab",
        "name": "Tests frame out",
        "links": [
            "613244fe49aa76c6"
        ],
        "x": 195,
        "y": 220,
        "wires": [
            [
                "6aced2a29121cd5b"
            ]
        ]
    },
    {
        "id": "cbfaa875d5a7e005",
        "type": "template",
        "z": "5cc5759c4e59a5b9",
        "g": "403d2b7b7f27eaab",
        "name": "",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "<===============================================================================>\n<=================================   ERROR   ===================================>\n<===============================================================================>\n{{error.message}}\n\nPlease be sure that the downlink strategie is one of th folowing:\n- compareToUplinkObject \n- compareToUplinkObjectWithinRange \n- onChangeOfThisValue\n- onChangeOfThisValueWithinRange\n\nFor more information see the documentation on Github.\nhttps://github.com/SylvainMontagny/LoRaBAC\n\nDevice concerned: **{{device}}**\nObject concerned: **{{object}}**\nProperty concerned: **{{property}}**\nActual value: **{{value}}**\n<===============================================================================>",
        "output": "str",
        "x": 565,
        "y": 1020,
        "wires": [
            [
                "395810ba2850e941"
            ]
        ],
        "icon": "node-red/comment.svg",
        "l": false
    },
    {
        "id": "f75024a426208b8a",
        "type": "mqtt-broker",
        "name": "Chirpstack-controller",
        "broker": "mosquitto",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    }
]